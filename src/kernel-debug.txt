     1                              <1> ORG 0x0000000000100000
     2                                  ; =============================================================================
     3                                  ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
     4                                  ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
     5                                  ;
     6                                  ; The BareMetal exokernel.
     7                                  ; =============================================================================
     8                                  
     9                                  
    10                                  BITS 64					; Specify 64-bit for flat binary
    11                                  
    12                                  %DEFINE BAREMETAL_VER 'v1.0.0 (November 13, 2017)', 13, 'Copyright (C) 2008-2017 Return Infinity', 13, 0
    13                                  %DEFINE BAREMETAL_API_VER 1
    14                                  KERNELSIZE equ 8192			; Pad the kernel to this length
    15                                  
    16                                  
    17                                  kernel_start:
    18 00000000 EB7E                    	jmp start			; Skip over the function call index
    19 00000002 90                      	nop
    20 00000003 424152454D4554414C      	db 'BAREMETAL'
    21                                  
    22 0000000C 90<rept>                align 16
    23 00000010 [DF04000000000000]      	dq b_input			; 0x0010
    24 00000018 [F604000000000000]      	dq b_output			; 0x0018
    25 00000020 [3509000000000000]      	dq b_smp_set			; 0x0020
    26 00000028 [7F09000000000000]      	dq b_smp_config			; 0x0028
    27 00000030 [1A05000000000000]      	dq b_mem_allocate		; 0x0030
    28 00000038 [7C05000000000000]      	dq b_mem_release		; 0x0038
    29 00000040 [D807000000000000]      	dq b_net_tx			; 0x0040
    30 00000048 [2608000000000000]      	dq b_net_rx			; 0x0048
    31 00000050 [7904000000000000]      	dq b_disk_read			; 0x0050
    32 00000058 [AC04000000000000]      	dq b_disk_write			; 0x0058
    33 00000060 [F505000000000000]      	dq b_system_config		; 0x0060
    34 00000068 [6906000000000000]      	dq b_system_misc		; 0x0068
    35 00000070 [7508000000000000]      	dq b_pci_read_config		; 0x0070
    36                                  
    37 00000078 90<rept>                align 16
    38                                  start:
    39 00000080 E8D3000000              	call init_64			; After this point we are in a working 64-bit environment
    40 00000085 E8D4030000              	call init_pci			; Initialize the PCI bus
    41 0000008A E8B8020000              	call init_hdd			; Initialize the disk
    42 0000008F E8B9020000              	call init_net			; Initialize the network
    43                                  
    44                                  	; Copy the payload after the kernel to the proper address
    45 00000094 BE00201000              	mov rsi, 0x100000 + KERNELSIZE	; Payload starts right after the kernel
    46 00000099 48833E00                	cmp qword [rsi], 0		; Is there a payload after the kernel?
    47 0000009D 7421                    	je ap_clear			; If not, skip to ap_clear
    48 0000009F BF00001E00              	mov rdi, 0x1E0000
    49 000000A4 B900080000              	mov rcx, 2048
    50 000000A9 F348A5                  	rep movsq			; Copy 16384 bytes
    51                                  
    52                                  	; Set the payload to run
    53 000000AC 48C7042580001100-       	mov qword [os_ClockCallback], init_process
    54 000000B4 [39010000]         
    55                                  
    56                                  	; Fall through to ap_clear as align fills the space with No-Ops
    57                                  	; At this point the BSP is just like one of the AP's
    58                                  
    59 000000B8 90<rept>                align 16
    60                                  ap_clear:				; All cores start here on first start-up and after an exception
    61 000000C0 FA                      	cli				; Disable interrupts on this core
    62                                  
    63                                  	; Get local ID of the core
    64 000000C1 488B342500001100        	mov rsi, [os_LocalAPICAddress]	; We can't use b_smp_get_id as no configured stack yet
    65 000000C9 31C0                    	xor eax, eax			; Clear Task Priority (bits 7:4) and Task Priority Sub-Class (bits 3:0)
    66 000000CB 898680000000            	mov dword [rsi+0x80], eax	; APIC Task Priority Register (TPR)
    67 000000D1 8B4620                  	mov eax, dword [rsi+0x20]	; APIC ID in upper 8 bits
    68 000000D4 C1E818                  	shr eax, 24			; Shift to the right and AL now holds the CPU's APIC ID
    69 000000D7 89C3                    	mov ebx, eax			; Save the APIC ID
    70                                  
    71                                  	; Set up the stack
    72 000000D9 48C1E015                	shl rax, 21			; Shift left 21 bits for a 2 MiB stack
    73 000000DD 4803042528001100        	add rax, [os_StackBase]		; The stack decrements when you "push", start at 2 MiB in
    74 000000E5 4883E808                	sub rax, 8
    75 000000E9 4889C4                  	mov rsp, rax
    76                                  
    77                                  	; Clear the entry in the work table
    78 000000EC 89D8                    	mov eax, ebx			; Restore the APIC ID
    79 000000EE BF00F01F00              	mov rdi, os_cpu_work_table
    80 000000F3 48C1E004                	shl rax, 4			; Quick multiply by 16 to get to proper record
    81 000000F7 4801C7                  	add rdi, rax
    82 000000FA 31C0                    	xor eax, eax
    83 000000FC 48AB                    	stosq				; Clear the code and data addresses
    84 000000FE 48AB                    	stosq
    85                                  
    86                                  	; Clear registers. Gives us a clean slate to work with
    87 00000100 31C0                    	xor eax, eax			; aka r0
    88 00000102 31C9                    	xor ecx, ecx			; aka r1
    89 00000104 31D2                    	xor edx, edx			; aka r2
    90 00000106 31DB                    	xor ebx, ebx			; aka r3
    91 00000108 31ED                    	xor ebp, ebp			; aka r5, We skip RSP (aka r4) as it was previously set
    92 0000010A 31F6                    	xor esi, esi			; aka r6
    93 0000010C 31FF                    	xor edi, edi			; aka r7
    94 0000010E 4D31C0                  	xor r8, r8
    95 00000111 4D31C9                  	xor r9, r9
    96 00000114 4D31D2                  	xor r10, r10
    97 00000117 4D31DB                  	xor r11, r11
    98 0000011A 4D31E4                  	xor r12, r12
    99 0000011D 4D31ED                  	xor r13, r13
   100 00000120 4D31F6                  	xor r14, r14
   101 00000123 4D31FF                  	xor r15, r15
   102                                  
   103 00000126 FB                      	sti				; Enable interrupts on this core
   104                                  
   105                                  ap_check:
   106 00000127 E838080000              	call b_smp_get_work		; Check for an assigned workload
   107 0000012C 4883F800                	cmp rax, 0			; If 0 then there is nothing to do
   108 00000130 7503                    	jne ap_process
   109                                  
   110                                  ap_halt:				; Halt until a wakeup call is received
   111 00000132 F4                      	hlt
   112 00000133 EBF2                    	jmp ap_check			; Core will jump to ap_check when it wakes up
   113                                  
   114                                  ap_process:
   115 00000135 FFD0                    	call rax			; Run the code
   116 00000137 EB87                    	jmp ap_clear			; Reset the stack, clear the registers, and wait for something else to work on
   117                                  
   118                                  init_process:
   119 00000139 E8E1070000              	call b_smp_get_id		; Get the ID of the current core
   120 0000013E 4889C1                  	mov rcx, rax
   121 00000141 B800001E00              	mov rax, 0x1E0000		; Payload was copied here
   122 00000146 E8EA070000              	call b_smp_set
   123 0000014B 48C704258000110000-     	mov qword [os_ClockCallback], 0	; Clear the callback
   124 00000154 000000             
   125 00000157 C3                      	ret
   126                                  
   127                                  ; Includes
   128                                  %include "init.asm"
   129                              <1> ; =============================================================================
   130                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   131                              <1> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   132                              <1> ;
   133                              <1> ; Initialization Includes
   134                              <1> ; =============================================================================
   135                              <1> 
   136                              <1> 
   137                              <1> %include "init/64.asm"
   138                              <2> ; =============================================================================
   139                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   140                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   141                              <2> ;
   142                              <2> ; 64-bit initialization
   143                              <2> ; =============================================================================
   144                              <2> 
   145                              <2> 
   146                              <2> ; -----------------------------------------------------------------------------
   147                              <2> init_64:
   148                              <2> 	; Clear system variables area
   149 00000158 BF00001100          <2> 	mov rdi, os_SystemVariables
   150 0000015D B900E00100          <2> 	mov rcx, 122880            ; Clear 960 KiB
   151 00000162 31C0                <2> 	xor eax, eax
   152 00000164 F348AB              <2> 	rep stosq
   153                              <2> 	; Configure the CPU work table
   154 00000167 BF00F01F00          <2> 	mov rdi, os_cpu_work_table
   155 0000016C B900020000          <2> 	mov rcx, 512
   156 00000171 48C7C0FFFFFFFF      <2> 	mov rax, 0xFFFFFFFFFFFFFFFF	; Value for a non-present CPU
   157 00000178 F348AB              <2> 	rep stosq
   158                              <2> 
   159                              <2> 	; Create the 64-bit IDT (at linear address 0x0000000000000000) as defined by Pure64
   160 0000017B 31FF                <2> 	xor edi, edi
   161                              <2> 
   162                              <2> 	; Create exception gate stubs (Pure64 has already set the correct gate markers)
   163 0000017D B920000000          <2> 	mov rcx, 32
   164 00000182 48B8-               <2> 	mov rax, exception_gate
   165 00000184 [E810000000000000]  <2>
   166                              <2> make_exception_gate_stubs:
   167 0000018C E83E010000          <2> 	call create_gate
   168 00000191 48FFC7              <2> 	inc rdi
   169 00000194 48FFC9              <2> 	dec rcx
   170 00000197 75F3                <2> 	jnz make_exception_gate_stubs
   171                              <2> 
   172                              <2> 	; Create interrupt gate stubs (Pure64 has already set the correct gate markers)
   173 00000199 B9E0000000          <2> 	mov rcx, 256-32
   174 0000019E 48B8-               <2> 	mov rax, interrupt_gate
   175 000001A0 [0811000000000000]  <2>
   176                              <2> make_interrupt_gate_stubs:
   177 000001A8 E822010000          <2> 	call create_gate
   178 000001AD 48FFC7              <2> 	inc rdi
   179 000001B0 48FFC9              <2> 	dec rcx
   180 000001B3 75F3                <2> 	jnz make_interrupt_gate_stubs
   181                              <2> 
   182                              <2> 	; Set up the exception gates for all of the CPU exceptions
   183 000001B5 B914000000          <2> 	mov rcx, 20
   184 000001BA 4831FF              <2> 	xor rdi, rdi
   185 000001BD 48B8-               <2> 	mov rax, exception_gate_00
   186 000001BF [0013000000000000]  <2>
   187                              <2> make_exception_gates:
   188 000001C7 E803010000          <2> 	call create_gate
   189 000001CC 48FFC7              <2> 	inc rdi
   190 000001CF 4883C010            <2> 	add rax, 16			; The exception gates are aligned at 16 bytes
   191 000001D3 48FFC9              <2> 	dec rcx
   192 000001D6 75EF                <2> 	jnz make_exception_gates
   193                              <2> 
   194                              <2> 	; Set up the IRQ handlers (Network IRQ handler is configured in init_net)
   195 000001D8 BF21000000          <2> 	mov rdi, 0x21
   196 000001DD 48B8-               <2> 	mov rax, keyboard
   197 000001DF [1011000000000000]  <2>
   198 000001E7 E8E3000000          <2> 	call create_gate
   199 000001EC BF22000000          <2> 	mov rdi, 0x22
   200 000001F1 48B8-               <2> 	mov rax, cascade
   201 000001F3 [9011000000000000]  <2>
   202 000001FB E8CF000000          <2> 	call create_gate
   203 00000200 BF28000000          <2> 	mov rdi, 0x28
   204 00000205 48B8-               <2> 	mov rax, rtc
   205 00000207 [9811000000000000]  <2>
   206 0000020F E8BB000000          <2> 	call create_gate
   207 00000214 BF80000000          <2> 	mov rdi, 0x80
   208 00000219 48B8-               <2> 	mov rax, ap_wakeup
   209 0000021B [C012000000000000]  <2>
   210 00000223 E8A7000000          <2> 	call create_gate
   211 00000228 BF81000000          <2> 	mov rdi, 0x81
   212 0000022D 48B8-               <2> 	mov rax, ap_reset
   213 0000022F [D812000000000000]  <2>
   214 00000237 E893000000          <2> 	call create_gate
   215                              <2> 
   216                              <2> 	; Grab data from Pure64's infomap
   217 0000023C 31C0                <2> 	xor eax, eax
   218 0000023E 31DB                <2> 	xor ebx, ebx
   219 00000240 31C9                <2> 	xor ecx, ecx
   220 00000242 BE08500000          <2> 	mov rsi, 0x5008
   221 00000247 AD                  <2> 	lodsd				; Load the BSP ID
   222 00000248 89C3                <2> 	mov ebx, eax			; Save it to EBX
   223 0000024A BE12500000          <2> 	mov rsi, 0x5012
   224 0000024F 66AD                <2> 	lodsw				; Load the number of activated cores
   225 00000251 6689C1              <2> 	mov cx, ax			; Save it to CX
   226 00000254 BE60500000          <2> 	mov rsi, 0x5060
   227 00000259 48AD                <2> 	lodsq
   228 0000025B 4889042500001100    <2> 	mov [os_LocalAPICAddress], rax
   229 00000263 48AD                <2> 	lodsq
   230 00000265 4889042508001100    <2> 	mov [os_IOAPICAddress], rax
   231 0000026D BE12500000          <2> 	mov rsi, 0x5012
   232 00000272 66AD                <2> 	lodsw
   233 00000274 6689042500021100    <2> 	mov [os_NumCores], ax
   234 0000027C BE20500000          <2> 	mov rsi, 0x5020
   235 00000281 AD                  <2> 	lodsd
   236 00000282 89042508011100      <2> 	mov [os_MemAmount], eax		; In MiB's
   237 00000289 BE40500000          <2> 	mov rsi, 0x5040
   238 0000028E 48AD                <2> 	lodsq
   239 00000290 4889042558001100    <2> 	mov [os_HPETAddress], rax
   240                              <2> 
   241                              <2> 	; Build the OS memory table
   242 00000298 E84C000000          <2> 	call init_memory_map
   243                              <2> 
   244                              <2> 	; Initialize all AP's to run our reset code. Skip the BSP
   245 0000029D 4831C0              <2> 	xor rax, rax
   246 000002A0 BE00510000          <2> 	mov rsi, 0x0000000000005100	; Location in memory of the Pure64 CPU data
   247                              <2> next_ap:
   248 000002A5 6685C9              <2> 	test cx, cx
   249 000002A8 740F                <2> 	jz no_more_aps
   250 000002AA AC                  <2> 	lodsb				; Load the CPU APIC ID
   251 000002AB 38D8                <2> 	cmp al, bl
   252 000002AD 7405                <2> 	je skip_ap
   253 000002AF E80B060000          <2> 	call b_smp_reset		; Reset the CPU
   254                              <2> skip_ap:
   255 000002B4 66FFC9              <2> 	dec cx
   256 000002B7 EBEC                <2> 	jmp next_ap
   257                              <2> no_more_aps:
   258                              <2> 
   259                              <2> 	; Enable specific interrupts
   260 000002B9 B001                <2> 	mov al, 0x01			; Keyboard IRQ
   261 000002BB E832070000          <2> 	call os_pic_mask_clear
   262 000002C0 B002                <2> 	mov al, 0x02			; Cascade IRQ
   263 000002C2 E82B070000          <2> 	call os_pic_mask_clear
   264 000002C7 B008                <2> 	mov al, 0x08			; RTC IRQ
   265 000002C9 E824070000          <2> 	call os_pic_mask_clear
   266                              <2> 
   267 000002CE C3                  <2> 	ret
   268                              <2> ; -----------------------------------------------------------------------------
   269                              <2> 
   270                              <2> 
   271                              <2> ; -----------------------------------------------------------------------------
   272                              <2> ; create_gate
   273                              <2> ; rax = address of handler
   274                              <2> ; rdi = gate # to configure
   275                              <2> create_gate:
   276 000002CF 57                  <2> 	push rdi
   277 000002D0 50                  <2> 	push rax
   278                              <2> 
   279 000002D1 48C1E704            <2> 	shl rdi, 4			; quickly multiply rdi by 16
   280 000002D5 66AB                <2> 	stosw				; store the low word (15..0)
   281 000002D7 48C1E810            <2> 	shr rax, 16
   282 000002DB 4883C704            <2> 	add rdi, 4			; skip the gate marker
   283 000002DF 66AB                <2> 	stosw				; store the high word (31..16)
   284 000002E1 48C1E810            <2> 	shr rax, 16
   285 000002E5 AB                  <2> 	stosd				; store the high dword (63..32)
   286                              <2> 
   287 000002E6 58                  <2> 	pop rax
   288 000002E7 5F                  <2> 	pop rdi
   289 000002E8 C3                  <2> 	ret
   290                              <2> ; -----------------------------------------------------------------------------
   291                              <2> 
   292                              <2> 
   293                              <2> ; -----------------------------------------------------------------------------
   294                              <2> init_memory_map:			; Build the OS memory table
   295 000002E9 50                  <2> 	push rax
   296 000002EA 51                  <2> 	push rcx
   297 000002EB 57                  <2> 	push rdi
   298                              <2> 
   299                              <2> 	; Build a fresh memory map for the system
   300 000002EC BF00001200          <2> 	mov rdi, os_MemoryMap
   301 000002F1 57                  <2> 	push rdi
   302 000002F2 4831C9              <2> 	xor rcx, rcx
   303 000002F5 668B0C2508011100    <2> 	mov cx, [os_MemAmount]
   304 000002FD 66D1E9              <2> 	shr cx, 1			; Divide actual memory by 2
   305 00000300 B001                <2> 	mov al, 1
   306 00000302 F3AA                <2> 	rep stosb
   307 00000304 5F                  <2> 	pop rdi
   308 00000305 B002                <2> 	mov al, 2
   309 00000307 AA                  <2> 	stosb				; Mark the first 2 MiB as in use (by Kernel and system buffers)
   310                              <2> 	; The CLI should take care of the Application memory
   311                              <2> 
   312                              <2> 	; Allocate memory for CPU stacks (2 MiB's for each core)
   313 00000308 4831C9              <2> 	xor rcx, rcx
   314 0000030B 668B0C2500021100    <2> 	mov cx, [os_NumCores]		; Get the amount of cores in the system
   315 00000313 E802020000          <2> 	call b_mem_allocate		; Allocate a page for each core
   316 00000318 4885C9              <2> 	test rcx, rcx			; b_mem_allocate returns 0 on failure
   317 0000031B 7412                <2> 	jz system_failure
   318 0000031D 480500002000        <2> 	add rax, 2097152
   319 00000323 4889042528001100    <2> 	mov [os_StackBase], rax		; Store the Stack base address
   320                              <2> 
   321 0000032B 5F                  <2> 	pop rdi
   322 0000032C 59                  <2> 	pop rcx
   323 0000032D 58                  <2> 	pop rax
   324 0000032E C3                  <2> 	ret
   325                              <2> ; -----------------------------------------------------------------------------
   326                              <2> 
   327                              <2> 
   328                              <2> ; -----------------------------------------------------------------------------
   329                              <2> system_failure:
   330 0000032F 48BE-               <2> 	mov rsi, memory_message
   331 00000331 [6015000000000000]  <2>
   332 00000339 B937000000          <2> 	mov rcx, 55
   333 0000033E E8B3010000          <2> 	call b_output
   334                              <2> system_failure_hang:
   335 00000343 F4                  <2> 	hlt
   336 00000344 EBFD                <2> 	jmp system_failure_hang
   337 00000346 C3                  <2> 	ret
   338                              <2> ; -----------------------------------------------------------------------------
   339                              <2> 
   340                              <2> 
   341                              <2> ; =============================================================================
   342                              <2> ; EOF
   343                              <1> %include "init/hdd.asm"
   344                              <2> ; =============================================================================
   345                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   346                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   347                              <2> ;
   348                              <2> ; Initialize disk
   349                              <2> ; =============================================================================
   350                              <2> 
   351                              <2> 
   352                              <2> ; -----------------------------------------------------------------------------
   353                              <2> init_hdd:
   354 00000347 E8CD060000          <2> 	call ahci_init
   355 0000034C C3                  <2> 	ret
   356                              <2> ; -----------------------------------------------------------------------------
   357                              <2> 
   358                              <2> 
   359                              <2> ; =============================================================================
   360                              <2> ; EOF
   361                              <1> %include "init/net.asm"
   362                              <2> ; =============================================================================
   363                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   364                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   365                              <2> ;
   366                              <2> ; Initialize network
   367                              <2> ; =============================================================================
   368                              <2> 
   369                              <2> 
   370                              <2> ; -----------------------------------------------------------------------------
   371                              <2> init_net:
   372                              <2> 	; Search for a supported NIC
   373 0000034D 31DB                <2> 	xor ebx, ebx			; Clear the Bus number
   374 0000034F 31C9                <2> 	xor ecx, ecx			; Clear the Device/Slot number
   375 00000351 BA02000000          <2> 	mov edx, 2			; Register 2 for Class code/Subclass
   376                              <2> 
   377                              <2> init_net_probe_next:
   378 00000356 E83B060000          <2> 	call os_pci_read_reg
   379 0000035B C1E810              <2> 	shr eax, 16			; Move the Class/Subclass code to AX
   380 0000035E 663D0002            <2> 	cmp ax, 0x0200			; Network Controller (02) / Ethernet (00)
   381 00000362 7420                <2> 	je init_net_probe_find_driver	; Found a Network Controller... now search for a driver
   382 00000364 83C101              <2> 	add ecx, 1
   383 00000367 81F900010000        <2> 	cmp ecx, 256			; Maximum 256 devices/functions per bus
   384 0000036D 7402                <2> 	je init_net_probe_next_bus
   385 0000036F EBE5                <2> 	jmp init_net_probe_next
   386                              <2> 
   387                              <2> init_net_probe_next_bus:
   388 00000371 31C9                <2> 	xor ecx, ecx
   389 00000373 83C301              <2> 	add ebx, 1
   390 00000376 81FB00010000        <2> 	cmp ebx, 256			; Maximum 256 buses
   391 0000037C 0F84DB000000        <2> 	je init_net_probe_not_found
   392 00000382 EBD2                <2> 	jmp init_net_probe_next
   393                              <2> 
   394                              <2> init_net_probe_find_driver:
   395 00000384 31D2                <2> 	xor edx, edx			; Register 0 for Device/Vendor ID
   396 00000386 E80B060000          <2> 	call os_pci_read_reg		; Read the Device/Vendor ID from the PCI device
   397 0000038B 4189C0              <2> 	mov r8d, eax			; Save the Device/Vendor ID in R8D
   398 0000038E 48BE-               <2> 	mov rsi, NIC_DeviceVendor_ID
   399 00000390 [3510000000000000]  <2>
   400 00000398 AD                  <2> 	lodsd				; Load a driver ID - Low half must be 0xFFFF
   401                              <2> init_net_probe_find_next_driver:
   402 00000399 4889C2              <2> 	mov rdx, rax			; Save the driver ID
   403                              <2> init_net_probe_find_next_device:
   404 0000039C AD                  <2> 	lodsd				; Load a device and vendor ID from our list of supported NICs
   405 0000039D 85C0                <2> 	test eax, eax			; 0x00000000 means we have reached the end of the list
   406 0000039F 0F84B8000000        <2> 	jz init_net_probe_not_found	; No supported NIC found
   407 000003A5 6683F8FF            <2> 	cmp ax, 0xFFFF			; New driver ID?
   408 000003A9 74EE                <2> 	je init_net_probe_find_next_driver	; We found the next driver type
   409 000003AB 4439C0              <2> 	cmp eax, r8d
   410 000003AE 7402                <2> 	je init_net_probe_found		; If Carry is clear then we found a supported NIC
   411 000003B0 EBEA                <2> 	jmp init_net_probe_find_next_device	; Check the next device
   412                              <2> 
   413                              <2> init_net_probe_found:
   414 000003B2 81FAFFFF5482        <2> 	cmp edx, 0x8254FFFF
   415 000003B8 740D                <2> 	je init_net_probe_found_i8254x
   416 000003BA 81FAFFFFF41A        <2> 	cmp edx, 0x1AF4FFFF
   417 000003C0 7435                <2> 	je init_net_probe_found_virtio
   418 000003C2 E996000000          <2> 	jmp init_net_probe_not_found
   419                              <2> 
   420                              <2> init_net_probe_found_i8254x:
   421 000003C7 E854090000          <2> 	call net_i8254x_init
   422 000003CC BF30001100          <2> 	mov rdi, os_net_transmit
   423 000003D1 48B8-               <2> 	mov rax, net_i8254x_transmit
   424 000003D3 [300F000000000000]  <2>
   425 000003DB 48AB                <2> 	stosq
   426 000003DD 48B8-               <2> 	mov rax, net_i8254x_poll
   427 000003DF [6B0F000000000000]  <2>
   428 000003E7 48AB                <2> 	stosq
   429 000003E9 48B8-               <2> 	mov rax, net_i8254x_ack_int
   430 000003EB [A80F000000000000]  <2>
   431 000003F3 48AB                <2> 	stosq
   432 000003F5 EB30                <2> 	jmp init_net_probe_found_finish
   433                              <2> 
   434                              <2> init_net_probe_found_virtio:
   435 000003F7 E8BF0B0000          <2> 	call net_virtio_init
   436 000003FC BF30001100          <2> 	mov rdi, os_net_transmit
   437 00000401 48B8-               <2> 	mov rax, net_virtio_transmit
   438 00000403 [3210000000000000]  <2>
   439 0000040B 48AB                <2> 	stosq
   440 0000040D 48B8-               <2> 	mov rax, net_virtio_poll
   441 0000040F [3310000000000000]  <2>
   442 00000417 48AB                <2> 	stosq
   443 00000419 48B8-               <2> 	mov rax, net_virtio_ack_int
   444 0000041B [3410000000000000]  <2>
   445 00000423 48AB                <2> 	stosq
   446 00000425 EB00                <2> 	jmp init_net_probe_found_finish
   447                              <2> 
   448                              <2> init_net_probe_found_finish:
   449 00000427 31C0                <2> 	xor eax, eax
   450 00000429 8A04250A031100      <2> 	mov al, [os_NetIRQ]
   451                              <2> 
   452 00000430 0420                <2> 	add al, 0x20
   453 00000432 4889C7              <2> 	mov rdi, rax
   454 00000435 48B8-               <2> 	mov rax, network
   455 00000437 [0012000000000000]  <2>
   456 0000043F E88BFEFFFF          <2> 	call create_gate
   457                              <2> 
   458                              <2> 	; Enable the Network IRQ
   459 00000444 8A04250A031100      <2> 	mov al, [os_NetIRQ]
   460 0000044B E8A2050000          <2> 	call os_pic_mask_clear
   461                              <2> 
   462 00000450 C604250803110001    <2> 	mov byte [os_NetEnabled], 1	; A supported NIC was found. Signal to the OS that networking is enabled
   463 00000458 E8F7030000          <2> 	call b_net_ack_int		; Call the driver function to acknowledge the interrupt internally
   464                              <2> 
   465                              <2> init_net_probe_not_found:
   466                              <2> 
   467 0000045D C3                  <2> 	ret
   468                              <2> ; -----------------------------------------------------------------------------
   469                              <2> 
   470                              <2> 
   471                              <2> ; =============================================================================
   472                              <2> ; EOF
   473                              <1> %include "init/pci.asm"
   474                              <2> ; =============================================================================
   475                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   476                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   477                              <2> ;
   478                              <2> ; Initialize PCI
   479                              <2> ; =============================================================================
   480                              <2> 
   481                              <2> 
   482                              <2> ; -----------------------------------------------------------------------------
   483                              <2> init_pci:
   484 0000045E B800000080          <2> 	mov eax, 0x80000000
   485 00000463 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
   486 00000467 EF                  <2> 	out dx, eax
   487 00000468 ED                  <2> 	in eax, dx
   488 00000469 3D00000080          <2> 	cmp eax, 0x80000000
   489 0000046E 7508                <2> 	jne init_pci_not_found
   490 00000470 C604250703110001    <2> 	mov byte [os_PCIEnabled], 1
   491                              <2> 
   492                              <2> init_pci_not_found:
   493 00000478 C3                  <2> 	ret
   494                              <2> ; -----------------------------------------------------------------------------
   495                              <2> 
   496                              <2> 
   497                              <2> ; =============================================================================
   498                              <2> ; EOF
   499                              <1> 
   500                              <1> 
   501                              <1> ; =============================================================================
   502                              <1> ; EOF
   503                                  %include "syscalls.asm"
   504                              <1> ; =============================================================================
   505                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   506                              <1> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   507                              <1> ;
   508                              <1> ; System Call Section -- Accessible to user programs
   509                              <1> ; =============================================================================
   510                              <1> 
   511                              <1> 
   512                              <1> %include "syscalls/disk.asm"
   513                              <2> ; =============================================================================
   514                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   515                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   516                              <2> ;
   517                              <2> ; Disk Block Storage Functions
   518                              <2> ; =============================================================================
   519                              <2> 
   520                              <2> 
   521                              <2> ; NOTE: BareMetal uses 4096 byte sectors.
   522                              <2> 
   523                              <2> 
   524                              <2> ; -----------------------------------------------------------------------------
   525                              <2> ; b_disk_read -- Read sectors from the disk
   526                              <2> ; IN:	RAX = Starting sector
   527                              <2> ;	RCX = Number of sectors to read
   528                              <2> ;	RDX = Disk
   529                              <2> ;	RDI = Memory location to store data
   530                              <2> ; OUT:	RCX = Number of sectors read
   531                              <2> ;	All other registers preserved
   532                              <2> b_disk_read:
   533 00000479 57                  <2> 	push rdi
   534 0000047A 51                  <2> 	push rcx
   535 0000047B 50                  <2> 	push rax
   536                              <2> 
   537 0000047C 803C250F03110001    <2> 	cmp byte [os_DiskEnabled], 1	; Make sure that a disk is present
   538 00000484 7520                <2> 	jne b_disk_read_error
   539                              <2> 
   540 00000486 4883F900            <2> 	cmp rcx, 0
   541 0000048A 741A                <2> 	je b_disk_read_error		; Bail out if instructed to read nothing
   542 0000048C 48C1E003            <2> 	shl rax, 3			; Convert to 512B starting sector
   543                              <2> 
   544                              <2> b_disk_read_loop:			; Read one sector at a time
   545 00000490 51                  <2> 	push rcx
   546 00000491 B908000000          <2> 	mov rcx, 8			; 8 512B sectors = 1 4K sector
   547 00000496 E8FF060000          <2> 	call ahci_read			; Driver deals with 512B sectors
   548 0000049B 59                  <2> 	pop rcx
   549 0000049C 4883E901            <2> 	sub rcx, 1
   550 000004A0 75EE                <2> 	jnz b_disk_read_loop
   551                              <2> 
   552                              <2> b_disk_read_done:
   553 000004A2 58                  <2> 	pop rax
   554 000004A3 59                  <2> 	pop rcx
   555 000004A4 5F                  <2> 	pop rdi
   556 000004A5 C3                  <2> 	ret
   557                              <2> 
   558                              <2> b_disk_read_error:
   559 000004A6 58                  <2> 	pop rax
   560 000004A7 59                  <2> 	pop rcx
   561 000004A8 5F                  <2> 	pop rdi
   562 000004A9 31C9                <2> 	xor ecx, ecx
   563 000004AB C3                  <2> 	ret
   564                              <2> ; -----------------------------------------------------------------------------
   565                              <2> 
   566                              <2> 
   567                              <2> ; -----------------------------------------------------------------------------
   568                              <2> ; b_disk_write -- Write sectors to the disk
   569                              <2> ; IN:	RAX = Starting sector
   570                              <2> ;	RCX = Number of sectors to write
   571                              <2> ;	RDX = Disk
   572                              <2> ;	RSI = Memory location of data
   573                              <2> ; OUT:	RCX = Number of sectors written
   574                              <2> ;	All other registers preserved
   575                              <2> b_disk_write:
   576 000004AC 56                  <2> 	push rsi
   577 000004AD 51                  <2> 	push rcx
   578 000004AE 50                  <2> 	push rax
   579                              <2> 
   580 000004AF 803C250F03110001    <2> 	cmp byte [os_DiskEnabled], 1	; Make sure that a disk is present
   581 000004B7 7520                <2> 	jne b_disk_write_error
   582                              <2> 
   583 000004B9 4883F900            <2> 	cmp rcx, 0
   584 000004BD 741A                <2> 	je b_disk_write_error		; Bail out if instructed to write nothing
   585 000004BF 48C1E003            <2> 	shl rax, 3			; Convert to 512B starting sector
   586                              <2> 
   587                              <2> b_disk_write_loop:			; Write one sector at a time
   588 000004C3 51                  <2> 	push rcx
   589 000004C4 B908000000          <2> 	mov rcx, 8			; 8 512B sectors = 1 4K sector
   590 000004C9 E88F070000          <2> 	call ahci_write			; Driver deals with 512B sectors
   591 000004CE 59                  <2> 	pop rcx
   592 000004CF 4883E901            <2> 	sub rcx, 1
   593 000004D3 75EE                <2> 	jnz b_disk_write_loop
   594                              <2> 
   595                              <2> b_disk_write_done:
   596 000004D5 58                  <2> 	pop rax
   597 000004D6 59                  <2> 	pop rcx
   598 000004D7 5E                  <2> 	pop rsi
   599 000004D8 C3                  <2> 	ret
   600                              <2> 
   601                              <2> b_disk_write_error:
   602 000004D9 58                  <2> 	pop rax
   603 000004DA 59                  <2> 	pop rcx
   604 000004DB 5E                  <2> 	pop rsi
   605 000004DC 31C9                <2> 	xor ecx, ecx
   606 000004DE C3                  <2> 	ret
   607                              <2> ; -----------------------------------------------------------------------------
   608                              <2> 
   609                              <2> 
   610                              <2> ; =============================================================================
   611                              <2> ; EOF
   612                              <1> %include "syscalls/io.asm"
   613                              <2> ; =============================================================================
   614                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   615                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   616                              <2> ;
   617                              <2> ; Input/Output Functions
   618                              <2> ; =============================================================================
   619                              <2> 
   620                              <2> 
   621                              <2> ; -----------------------------------------------------------------------------
   622                              <2> ; b_input -- Scans keyboard for input
   623                              <2> ;  IN:	Nothing
   624                              <2> ; OUT:	AL = 0 if no key pressed, otherwise ASCII code, other regs preserved
   625                              <2> ;	Carry flag is set if there was a keystroke, clear if there was not
   626                              <2> ;	All other registers preserved
   627                              <2> b_input:
   628 000004DF 8A042503031100      <2> 	mov al, [key]
   629 000004E6 84C0                <2> 	test al, al
   630 000004E8 740A                <2> 	jz b_input_no_key
   631 000004EA C604250303110000    <2> 	mov byte [key], 0x00		; clear the variable as the keystroke is in AL now
   632 000004F2 F9                  <2> 	stc				; set the carry flag
   633 000004F3 C3                  <2> 	ret
   634                              <2> 
   635                              <2> b_input_no_key:
   636 000004F4 F8                  <2> 	clc				; clear the carry flag
   637 000004F5 C3                  <2> 	ret
   638                              <2> ; -----------------------------------------------------------------------------
   639                              <2> 
   640                              <2> 
   641                              <2> ; -----------------------------------------------------------------------------
   642                              <2> ; b_output -- Outputs characters
   643                              <2> ;  IN:	RSI = message location (non zero-terminated)
   644                              <2> ;	RCX = number of chars to output
   645                              <2> ; OUT:	All registers preserved
   646                              <2> b_output:
   647 000004F6 56                  <2> 	push rsi			; Message location
   648 000004F7 52                  <2> 	push rdx			; Serial port address
   649 000004F8 51                  <2> 	push rcx			; Counter of chars left to output
   650 000004F9 50                  <2> 	push rax			; AL is used for the serial port output
   651                              <2> 
   652 000004FA FC                  <2> 	cld				; Clear the direction flag.. we want to increment through the string
   653 000004FB 66BAF803            <2> 	mov dx, 0x03F8			; Address of first serial port
   654                              <2> 
   655                              <2> b_output_nextchar:
   656 000004FF E314                <2> 	jrcxz b_output_done		; If RCX is 0 then the function is complete
   657 00000501 6683C205            <2> 	add dx, 5			; Offset to Line Status Register
   658 00000505 EC                  <2> 	in al, dx
   659 00000506 6683EA05            <2> 	sub dx, 5			; Back to to base
   660 0000050A 3C00                <2> 	cmp al, 0
   661 0000050C 74F1                <2> 	je b_output_nextchar
   662 0000050E 48FFC9              <2> 	dec rcx
   663 00000511 AC                  <2> 	lodsb				; Get char from string and store in AL
   664 00000512 EE                  <2> 	out dx, al			; Send the char to the serial port
   665 00000513 EBEA                <2> 	jmp b_output_nextchar
   666                              <2> 
   667                              <2> b_output_done:
   668 00000515 58                  <2> 	pop rax
   669 00000516 59                  <2> 	pop rcx
   670 00000517 5A                  <2> 	pop rdx
   671 00000518 5E                  <2> 	pop rsi
   672 00000519 C3                  <2> 	ret
   673                              <2> ; -----------------------------------------------------------------------------
   674                              <2> 
   675                              <2> 
   676                              <2> ; =============================================================================
   677                              <2> ; EOF
   678                              <1> %include "syscalls/memory.asm"
   679                              <2> ; =============================================================================
   680                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   681                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   682                              <2> ;
   683                              <2> ; Memory functions
   684                              <2> ; =============================================================================
   685                              <2> 
   686                              <2> 
   687                              <2> ; -----------------------------------------------------------------------------
   688                              <2> ; b_mem_allocate -- Allocates the requested number of 2 MiB pages
   689                              <2> ;  IN:	RCX = Number of pages to allocate
   690                              <2> ; OUT:	RAX = Starting address (Set to 0 on failure)
   691                              <2> ; This function will only allocate continuous pages
   692                              <2> b_mem_allocate:
   693 0000051A 56                  <2> 	push rsi
   694 0000051B 52                  <2> 	push rdx
   695 0000051C 53                  <2> 	push rbx
   696                              <2> 
   697 0000051D 4885C9              <2> 	test rcx, rcx
   698 00000520 7452                <2> 	jz b_mem_allocate_fail		; At least 1 page must be allocated
   699                              <2> 
   700                              <2> 	; Here, we'll load the last existing page of memory in RSI.
   701                              <2> 	; RAX and RSI instructions are purposefully interleaved.
   702                              <2> 
   703 00000522 4831C0              <2> 	xor rax, rax
   704 00000525 BE00001200          <2> 	mov rsi, os_MemoryMap		; First available memory block
   705 0000052A 8B042508011100      <2> 	mov eax, [os_MemAmount]		; Total memory in MiB from a double-word
   706 00000531 4889F2              <2> 	mov rdx, rsi			; Keep os_MemoryMap unmodified for later in RDX
   707 00000534 D1E8                <2> 	shr eax, 1			; Divide actual memory by 2
   708                              <2> 
   709 00000536 48FFCE              <2> 	dec rsi
   710 00000539 FD                  <2> 	std				; Set direction flag to backward
   711 0000053A 4801C6              <2> 	add rsi, rax			; RSI now points to the last page
   712                              <2> 
   713                              <2> b_mem_allocate_start:			; Find a free page of memory, from the end.
   714 0000053D 4889CB              <2> 	mov rbx, rcx			; RBX is our temporary counter
   715                              <2> 
   716                              <2> b_mem_allocate_nextpage:
   717 00000540 AC                  <2> 	lodsb
   718 00000541 4839D6              <2> 	cmp rsi, rdx			; We have hit the start of the memory map, no more free pages
   719 00000544 742E                <2> 	je b_mem_allocate_fail
   720                              <2> 
   721 00000546 3C01                <2> 	cmp al, 1
   722 00000548 75F3                <2> 	jne b_mem_allocate_start	; Page is taken, start counting from scratch
   723                              <2> 
   724 0000054A 48FFCB              <2> 	dec rbx				; We found a page! Any page left to find?
   725 0000054D 75F1                <2> 	jnz b_mem_allocate_nextpage
   726                              <2> 
   727                              <2> b_mem_allocate_mark:			; We have a suitable free series of pages. Allocate them.
   728 0000054F FC                  <2> 	cld				; Set direction flag to forward
   729                              <2> 
   730 00000550 4831F7              <2> 	xor rdi, rsi			; We swap rdi and rsi to keep rdi contents.
   731 00000553 4831FE              <2> 	xor rsi, rdi
   732 00000556 4831F7              <2> 	xor rdi, rsi
   733                              <2> 
   734                              <2> 	; Instructions are purposefully swapped at some places here to avoid
   735                              <2> 	; direct dependencies line after line.
   736 00000559 51                  <2> 	push rcx			; Keep RCX as is for the 'rep stosb' to come
   737 0000055A 48FFC7              <2> 	inc rdi
   738 0000055D B002                <2> 	mov al, 2
   739 0000055F 4889FB              <2> 	mov rbx, rdi			; RBX points to the starting page
   740 00000562 F3AA                <2> 	rep stosb
   741 00000564 4889F7              <2> 	mov rdi, rsi			; Restoring RDI
   742 00000567 4829D3              <2> 	sub rbx, rdx			; RBX now contains the memory page number
   743 0000056A 59                  <2> 	pop rcx 			; Restore RCX
   744                              <2> 
   745                              <2> 	; Only dependency left is between the two next lines.
   746 0000056B 48C1E315            <2> 	shl rbx, 21			; Quick multiply by 2097152 (2 MiB) to get the starting memory address
   747 0000056F 4889D8              <2> 	mov rax, rbx			; Return the starting address in RAX
   748 00000572 EB04                <2> 	jmp b_mem_allocate_end
   749                              <2> 
   750                              <2> b_mem_allocate_fail:
   751 00000574 FC                  <2> 	cld				; Set direction flag to forward
   752 00000575 4831C0              <2> 	xor rax, rax			; Failure so set RAX to 0 (No pages allocated)
   753                              <2> 
   754                              <2> b_mem_allocate_end:
   755 00000578 5B                  <2> 	pop rbx
   756 00000579 5A                  <2> 	pop rdx
   757 0000057A 5E                  <2> 	pop rsi
   758 0000057B C3                  <2> 	ret
   759                              <2> ; -----------------------------------------------------------------------------
   760                              <2> 
   761                              <2> 
   762                              <2> ; -----------------------------------------------------------------------------
   763                              <2> ; b_mem_release -- Frees the requested number of 2 MiB pages
   764                              <2> ;  IN:	RAX = Starting address
   765                              <2> ;	RCX = Number of pages to free
   766                              <2> ; OUT:	RCX = Number of pages freed
   767                              <2> b_mem_release:
   768 0000057C 57                  <2> 	push rdi
   769 0000057D 51                  <2> 	push rcx
   770 0000057E 50                  <2> 	push rax
   771                              <2> 
   772 0000057F 48C1E815            <2> 	shr rax, 21			; Quick divide by 2097152 (2 MiB) to get the starting page number
   773 00000583 480500001200        <2> 	add rax, os_MemoryMap
   774 00000589 4889C7              <2> 	mov rdi, rax
   775 0000058C B001                <2> 	mov al, 1
   776 0000058E F3AA                <2> 	rep stosb
   777                              <2> 
   778 00000590 58                  <2> 	pop rax
   779 00000591 59                  <2> 	pop rcx
   780 00000592 5F                  <2> 	pop rdi
   781 00000593 C3                  <2> 	ret
   782                              <2> ; -----------------------------------------------------------------------------
   783                              <2> 
   784                              <2> 
   785                              <2> ; -----------------------------------------------------------------------------
   786                              <2> ; b_mem_get_free -- Returns the number of 2 MiB pages that are available
   787                              <2> ;  IN:	Nothing
   788                              <2> ; OUT:	RCX = Number of free 2 MiB pages
   789                              <2> b_mem_get_free:
   790 00000594 56                  <2> 	push rsi
   791 00000595 53                  <2> 	push rbx
   792 00000596 50                  <2> 	push rax
   793                              <2> 
   794 00000597 BE00001200          <2> 	mov rsi, os_MemoryMap
   795 0000059C 4831C9              <2> 	xor rcx, rcx
   796 0000059F 4831DB              <2> 	xor rbx, rbx
   797                              <2> 
   798                              <2> b_mem_get_free_next:
   799 000005A2 AC                  <2> 	lodsb
   800 000005A3 48FFC1              <2> 	inc rcx
   801 000005A6 4881F900000100      <2> 	cmp rcx, 65536
   802 000005AD 7409                <2> 	je b_mem_get_free_end
   803 000005AF 3C01                <2> 	cmp al, 1
   804 000005B1 75EF                <2> 	jne b_mem_get_free_next
   805 000005B3 48FFC3              <2> 	inc rbx
   806 000005B6 EBEA                <2> 	jmp b_mem_get_free_next
   807                              <2> 
   808                              <2> b_mem_get_free_end:
   809 000005B8 4889D9              <2> 	mov rcx, rbx
   810                              <2> 
   811 000005BB 58                  <2> 	pop rax
   812 000005BC 5B                  <2> 	pop rbx
   813 000005BD 5E                  <2> 	pop rsi
   814 000005BE C3                  <2> 	ret
   815                              <2> ; -----------------------------------------------------------------------------
   816                              <2> 
   817                              <2> 
   818                              <2> ; =============================================================================
   819                              <2> ; EOF
   820                              <1> %include "syscalls/misc.asm"
   821                              <2> ; =============================================================================
   822                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
   823                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
   824                              <2> ;
   825                              <2> ; Misc Functions
   826                              <2> ; =============================================================================
   827                              <2> 
   828                              <2> 
   829                              <2> ; -----------------------------------------------------------------------------
   830                              <2> ; os_delay -- Delay by X eights of a second
   831                              <2> ; IN:	RAX = Time in eights of a second
   832                              <2> ; OUT:	All registers preserved
   833                              <2> ; A value of 8 in RAX will delay 1 second and a value of 1 will delay 1/8 of a second
   834                              <2> ; This function depends on the RTC (IRQ 8) so interrupts must be enabled.
   835                              <2> os_delay:
   836 000005BF 51                  <2> 	push rcx
   837 000005C0 50                  <2> 	push rax
   838                              <2> 
   839 000005C1 488B0C2510001100    <2> 	mov rcx, [os_ClockCounter]	; Grab the initial timer counter. It increments 8 times a second
   840 000005C9 4801C8              <2> 	add rax, rcx			; Add RCX so we get the end time we want
   841                              <2> os_delay_loop:
   842 000005CC 4839042510001100    <2> 	cmp qword [os_ClockCounter], rax	; Compare it against our end time
   843 000005D4 7EF6                <2> 	jle os_delay_loop		; Loop if RAX is still lower
   844                              <2> 
   845 000005D6 58                  <2> 	pop rax
   846 000005D7 59                  <2> 	pop rcx
   847 000005D8 C3                  <2> 	ret
   848                              <2> ; -----------------------------------------------------------------------------
   849                              <2> 
   850                              <2> 
   851                              <2> ; -----------------------------------------------------------------------------
   852                              <2> ; os_get_argv -- Get the value of an argument that was passed to the program
   853                              <2> ; IN:	RAX = Argument number
   854                              <2> ; OUT:	RAX = Start of numbered argument string
   855                              <2> os_get_argv:
   856 000005D9 56                  <2> 	push rsi
   857 000005DA 51                  <2> 	push rcx
   858 000005DB BE000C0800          <2> 	mov rsi, os_args
   859 000005E0 84C0                <2> 	test al, al
   860 000005E2 740B                <2> 	jz os_get_argv_end
   861 000005E4 88C1                <2> 	mov cl, al
   862                              <2> 
   863                              <2> os_get_argv_nextchar:
   864 000005E6 AC                  <2> 	lodsb
   865 000005E7 84C0                <2> 	test al, al
   866 000005E9 75FB                <2> 	jnz os_get_argv_nextchar
   867 000005EB FEC9                <2> 	dec cl
   868 000005ED 75F7                <2> 	jnz os_get_argv_nextchar
   869                              <2> 
   870                              <2> os_get_argv_end:
   871 000005EF 4889F0              <2> 	mov rax, rsi
   872 000005F2 59                  <2> 	pop rcx
   873 000005F3 5E                  <2> 	pop rsi
   874 000005F4 C3                  <2> 	ret
   875                              <2> ; -----------------------------------------------------------------------------
   876                              <2> 
   877                              <2> 
   878                              <2> ; -----------------------------------------------------------------------------
   879                              <2> ; b_system_config - View or modify system configuration options
   880                              <2> ; IN:	RDX = Function #
   881                              <2> ;	RAX = Variable
   882                              <2> ; OUT:	RAX = Result
   883                              <2> ;	All other registers preserved
   884                              <2> b_system_config:
   885 000005F5 4883FA00            <2> 	cmp rdx, 0
   886 000005F9 742B                <2> 	je b_system_config_timecounter
   887 000005FB 4883FA01            <2> 	cmp rdx, 1
   888 000005FF 742E                <2> 	je b_system_config_argc
   889 00000601 4883FA02            <2> 	cmp rdx, 2
   890 00000605 7432                <2> 	je b_system_config_argv
   891 00000607 4883FA03            <2> 	cmp rdx, 3
   892 0000060B 7432                <2> 	je b_system_config_networkcallback_get
   893 0000060D 4883FA04            <2> 	cmp rdx, 4
   894 00000611 7435                <2> 	je b_system_config_networkcallback_set
   895 00000613 4883FA05            <2> 	cmp rdx, 5
   896 00000617 7438                <2> 	je b_system_config_clockcallback_get
   897 00000619 4883FA06            <2> 	cmp rdx, 6
   898 0000061D 743B                <2> 	je b_system_config_clockcallback_set
   899 0000061F 4883FA1E            <2> 	cmp rdx, 30
   900 00000623 743E                <2> 	je b_system_config_mac
   901 00000625 C3                  <2> 	ret
   902                              <2> 
   903                              <2> b_system_config_timecounter:
   904 00000626 488B042510001100    <2> 	mov rax, [os_ClockCounter]	; Grab the timer counter value. It increments 8 times a second
   905 0000062E C3                  <2> 	ret
   906                              <2> 
   907                              <2> b_system_config_argc:
   908 0000062F 31C0                <2> 	xor eax, eax
   909 00000631 8A042511031100      <2> 	mov al, [app_argc]
   910 00000638 C3                  <2> 	ret
   911                              <2> 
   912                              <2> b_system_config_argv:
   913 00000639 E89BFFFFFF          <2> 	call os_get_argv
   914 0000063E C3                  <2> 	ret
   915                              <2> 
   916                              <2> b_system_config_networkcallback_get:
   917 0000063F 488B042568001100    <2> 	mov rax, [os_NetworkCallback]
   918 00000647 C3                  <2> 	ret
   919                              <2> 
   920                              <2> b_system_config_networkcallback_set:
   921 00000648 4889042568001100    <2> 	mov qword [os_NetworkCallback], rax
   922 00000650 C3                  <2> 	ret
   923                              <2> 
   924                              <2> b_system_config_clockcallback_get:
   925 00000651 488B042580001100    <2> 	mov rax, [os_ClockCallback]
   926 00000659 C3                  <2> 	ret
   927                              <2> 
   928                              <2> b_system_config_clockcallback_set:
   929 0000065A 4889042580001100    <2> 	mov qword [os_ClockCallback], rax
   930 00000662 C3                  <2> 	ret
   931                              <2> 
   932                              <2> b_system_config_mac:
   933 00000663 E848010000          <2> 	call b_net_status
   934 00000668 C3                  <2> 	ret
   935                              <2> ; -----------------------------------------------------------------------------
   936                              <2> 
   937                              <2> 
   938                              <2> ; -----------------------------------------------------------------------------
   939                              <2> ; b_system_misc - Call misc OS sub-functions
   940                              <2> ; IN:	RDX = Function #
   941                              <2> ;	RAX = Variable 1
   942                              <2> ;	RCX = Variable 2
   943                              <2> ; OUT:	RAX = Result 1, dependant on system call
   944                              <2> ;	RCX = Result 2, dependant on system call
   945                              <2> b_system_misc:
   946                              <2> ;	cmp rdx, X
   947                              <2> ;	je b_system_misc_
   948 00000669 4883FA01            <2> 	cmp rdx, 1
   949 0000066D 743A                <2> 	je b_system_misc_smp_get_id
   950 0000066F 4883FA02            <2> 	cmp rdx, 2
   951 00000673 743A                <2> 	je b_system_misc_smp_lock
   952 00000675 4883FA03            <2> 	cmp rdx, 3
   953 00000679 743A                <2> 	je b_system_misc_smp_unlock
   954 0000067B 4883FA04            <2> 	cmp rdx, 4
   955 0000067F 743A                <2> 	je b_system_misc_debug_dump_mem
   956 00000681 4883FA05            <2> 	cmp rdx, 5
   957 00000685 743A                <2> 	je b_system_misc_debug_dump_rax
   958 00000687 4883FA06            <2> 	cmp rdx, 6
   959 0000068B 743A                <2> 	je b_system_misc_delay
   960 0000068D 4883FA07            <2> 	cmp rdx, 7
   961 00000691 743A                <2> 	je b_system_misc_ethernet_status
   962 00000693 4883FA08            <2> 	cmp rdx, 8
   963 00000697 743A                <2> 	je b_system_misc_mem_get_free
   964 00000699 4883FA09            <2> 	cmp rdx, 9
   965 0000069D 743A                <2> 	je b_system_misc_smp_numcores
   966                              <2> ;	cmp rdx, 10
   967                              <2> ;	je b_system_misc_smp_queuelen
   968 0000069F 4881FA00010000      <2> 	cmp rdx, 256
   969 000006A6 743C                <2> 	je b_system_misc_reset
   970 000006A8 C3                  <2> 	ret
   971                              <2> 
   972                              <2> b_system_misc_smp_get_id:
   973 000006A9 E871020000          <2> 	call b_smp_get_id
   974 000006AE C3                  <2> 	ret
   975                              <2> 
   976                              <2> b_system_misc_smp_lock:
   977 000006AF E8CC020000          <2> 	call b_smp_lock
   978 000006B4 C3                  <2> 	ret
   979                              <2> 
   980                              <2> b_system_misc_smp_unlock:
   981 000006B5 E8D6020000          <2> 	call b_smp_unlock
   982 000006BA C3                  <2> 	ret
   983                              <2> 
   984                              <2> b_system_misc_debug_dump_mem:
   985 000006BB 56                  <2> 	push rsi
   986 000006BC 4889C6              <2> 	mov rsi, rax
   987 000006BF 5E                  <2> 	pop rsi
   988 000006C0 C3                  <2> 	ret
   989                              <2> 
   990                              <2> b_system_misc_debug_dump_rax:
   991 000006C1 E858000000          <2> 	call os_debug_dump_rax
   992 000006C6 C3                  <2> 	ret
   993                              <2> 
   994                              <2> b_system_misc_delay:
   995 000006C7 E8F3FEFFFF          <2> 	call os_delay
   996 000006CC C3                  <2> 	ret
   997                              <2> 
   998                              <2> b_system_misc_ethernet_status:
   999 000006CD E8DE000000          <2> 	call b_net_status
  1000 000006D2 C3                  <2> 	ret
  1001                              <2> 
  1002                              <2> b_system_misc_mem_get_free:
  1003 000006D3 E8BCFEFFFF          <2> 	call b_mem_get_free
  1004 000006D8 C3                  <2> 	ret
  1005                              <2> 
  1006                              <2> b_system_misc_smp_numcores:
  1007 000006D9 31C0                <2> 	xor eax, eax
  1008 000006DB 668B042500021100    <2> 	mov ax, [os_NumCores]
  1009 000006E3 C3                  <2> 	ret
  1010                              <2> 
  1011                              <2> b_system_misc_reset:
  1012 000006E4 31C0                <2> 	xor eax, eax
  1013 000006E6 4889042568001100    <2> 	mov qword [os_NetworkCallback], rax	; clear callbacks
  1014 000006EE 4889042580001100    <2> 	mov qword [os_ClockCallback], rax
  1015 000006F6 E824020000          <2> 	call b_smp_get_id		; Reset all other cpu cores
  1016 000006FB 4889C3              <2> 	mov rbx, rax
  1017 000006FE BE00510000          <2> 	mov rsi, 0x0000000000005100	; Location in memory of the Pure64 CPU data
  1018                              <2> b_system_misc_reset_next_ap:
  1019 00000703 6685C9              <2> 	test cx, cx
  1020 00000706 740F                <2> 	jz b_system_misc_reset_no_more_aps
  1021 00000708 AC                  <2> 	lodsb				; Load the CPU APIC ID
  1022 00000709 38D8                <2> 	cmp al, bl
  1023 0000070B 7405                <2> 	je b_system_misc_reset_skip_ap
  1024 0000070D E8AD010000          <2> 	call b_smp_reset		; Reset the CPU
  1025                              <2> b_system_misc_reset_skip_ap:
  1026 00000712 66FFC9              <2> 	dec cx
  1027 00000715 EBEC                <2> 	jmp b_system_misc_reset_next_ap
  1028                              <2> b_system_misc_reset_no_more_aps:
  1029 00000717 E8CDFBFFFF          <2> 	call init_memory_map		; Clear memory table
  1030 0000071C CD81                <2> 	int 0x81			; Reset this core
  1031                              <2> ; -----------------------------------------------------------------------------
  1032                              <2> 
  1033                              <2> 
  1034                              <2> ; -----------------------------------------------------------------------------
  1035                              <2> ; os_debug_dump_(rax|eax|ax|al) -- Dump content of RAX, EAX, AX, or AL to the screen in hex format
  1036                              <2> ;  IN:	RAX = content to dump
  1037                              <2> ; OUT:	Nothing, all registers preserved
  1038                              <2> os_debug_dump_rax:
  1039 0000071E 48C1C008            <2> 	rol rax, 8
  1040 00000722 E83F000000          <2> 	call os_debug_dump_al
  1041 00000727 48C1C008            <2> 	rol rax, 8
  1042 0000072B E836000000          <2> 	call os_debug_dump_al
  1043 00000730 48C1C008            <2> 	rol rax, 8
  1044 00000734 E82D000000          <2> 	call os_debug_dump_al
  1045 00000739 48C1C008            <2> 	rol rax, 8
  1046 0000073D E824000000          <2> 	call os_debug_dump_al
  1047 00000742 48C1C020            <2> 	rol rax, 32
  1048                              <2> os_debug_dump_eax:
  1049 00000746 C1C008              <2> 	rol eax, 8
  1050 00000749 E818000000          <2> 	call os_debug_dump_al
  1051 0000074E C1C008              <2> 	rol eax, 8
  1052 00000751 E810000000          <2> 	call os_debug_dump_al
  1053 00000756 C1C010              <2> 	rol eax, 16
  1054                              <2> os_debug_dump_ax:
  1055 00000759 66C1C008            <2> 	rol ax, 8
  1056 0000075D E804000000          <2> 	call os_debug_dump_al
  1057 00000762 66C1C008            <2> 	rol ax, 8
  1058                              <2> os_debug_dump_al:
  1059 00000766 53                  <2> 	push rbx
  1060 00000767 50                  <2> 	push rax
  1061 00000768 48BB-               <2> 	mov rbx, hextable
  1062 0000076A [2B15000000000000]  <2>
  1063 00000772 50                  <2> 	push rax			; Save RAX since we work in 2 parts
  1064 00000773 C0E804              <2> 	shr al, 4			; Shift high 4 bits into low 4 bits
  1065 00000776 D7                  <2> 	xlatb
  1066 00000777 880425[0E160000]    <2> 	mov [tchar+0], al
  1067 0000077E 58                  <2> 	pop rax
  1068 0000077F 240F                <2> 	and al, 0x0f			; Clear the high 4 bits
  1069 00000781 D7                  <2> 	xlatb
  1070 00000782 880425[0F160000]    <2> 	mov [tchar+1], al
  1071 00000789 56                  <2> 	push rsi
  1072 0000078A 51                  <2> 	push rcx
  1073 0000078B 48BE-               <2> 	mov rsi, tchar
  1074 0000078D [0E16000000000000]  <2>
  1075 00000795 B902000000          <2> 	mov rcx, 2
  1076 0000079A E857FDFFFF          <2> 	call b_output
  1077 0000079F 59                  <2> 	pop rcx
  1078 000007A0 5E                  <2> 	pop rsi
  1079 000007A1 58                  <2> 	pop rax
  1080 000007A2 5B                  <2> 	pop rbx
  1081 000007A3 C3                  <2> 	ret
  1082                              <2> ; -----------------------------------------------------------------------------
  1083                              <2> 
  1084                              <2> 
  1085                              <2> ; -----------------------------------------------------------------------------
  1086                              <2> ; reboot -- Reboot the computer
  1087                              <2> reboot:
  1088 000007A4 E464                <2> 	in al, 0x64
  1089 000007A6 A802                <2> 	test al, 00000010b		; Wait for an empty Input Buffer
  1090 000007A8 75FA                <2> 	jne reboot
  1091 000007AA B0FE                <2> 	mov al, 0xFE
  1092 000007AC E664                <2> 	out 0x64, al			; Send the reboot call to the keyboard controller
  1093 000007AE EBF4                <2> 	jmp reboot
  1094                              <2> ; -----------------------------------------------------------------------------
  1095                              <2> 
  1096                              <2> 
  1097                              <2> ; =============================================================================
  1098                              <2> ; EOF
  1099                              <1> %include "syscalls/net.asm"
  1100                              <2> ; =============================================================================
  1101                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1102                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1103                              <2> ;
  1104                              <2> ; Network Functions
  1105                              <2> ; =============================================================================
  1106                              <2> 
  1107                              <2> 
  1108                              <2> ; -----------------------------------------------------------------------------
  1109                              <2> ; b_net_status -- Check if network access is available
  1110                              <2> ;  IN:	Nothing
  1111                              <2> ; OUT:	RAX = MAC Address if net is enabled, otherwise 0
  1112                              <2> b_net_status:
  1113 000007B0 56                  <2> 	push rsi
  1114 000007B1 51                  <2> 	push rcx
  1115                              <2> 
  1116 000007B2 FC                  <2> 	cld
  1117 000007B3 31C0                <2> 	xor eax, eax
  1118 000007B5 803C250803110000    <2> 	cmp byte [os_NetEnabled], 0
  1119 000007BD 7416                <2> 	je b_net_status_end
  1120                              <2> 
  1121 000007BF B906000000          <2> 	mov ecx, 6
  1122 000007C4 BE50001100          <2> 	mov rsi, os_NetMAC
  1123                              <2> b_net_status_loadMAC:
  1124 000007C9 48C1E008            <2> 	shl rax, 8
  1125 000007CD AC                  <2> 	lodsb
  1126 000007CE 83E901              <2> 	sub ecx, 1
  1127 000007D1 85C9                <2> 	test ecx, ecx
  1128 000007D3 75F4                <2> 	jnz b_net_status_loadMAC
  1129                              <2> 
  1130                              <2> b_net_status_end:
  1131 000007D5 59                  <2> 	pop rcx
  1132 000007D6 5E                  <2> 	pop rsi
  1133 000007D7 C3                  <2> 	ret
  1134                              <2> ; -----------------------------------------------------------------------------
  1135                              <2> 
  1136                              <2> 
  1137                              <2> ; -----------------------------------------------------------------------------
  1138                              <2> ; b_net_tx -- Transmit a packet via the network
  1139                              <2> ;  IN:	RSI = Memory location where packet is stored
  1140                              <2> ;	RCX = Length of packet
  1141                              <2> ; OUT:	Nothing. All registers preserved
  1142                              <2> b_net_tx:
  1143 000007D8 51                  <2> 	push rcx
  1144 000007D9 50                  <2> 	push rax
  1145                              <2> 
  1146 000007DA 803C250803110001    <2> 	cmp byte [os_NetEnabled], 1	; Check if networking is enabled
  1147 000007E2 753F                <2> 	jne b_net_tx_fail
  1148 000007E4 4883F940            <2> 	cmp rcx, 64			; An net packet must be at least 64 bytes
  1149 000007E8 7D05                <2> 	jge b_net_tx_maxcheck
  1150 000007EA B940000000          <2> 	mov rcx, 64			; If it was below 64 then set to 64
  1151                              <2> 	; FIXME - OS should pad the packet with 0's before sending if less than 64
  1152                              <2> 
  1153                              <2> b_net_tx_maxcheck:
  1154 000007EF 4881F9F2050000      <2> 	cmp rcx, 1522			; Fail if more than 1522 bytes
  1155 000007F6 7F2B                <2> 	jg b_net_tx_fail
  1156                              <2> 
  1157 000007F8 B80C021100          <2> 	mov rax, os_NetLock		; Lock the net so only one send can happen at a time
  1158 000007FD E87E010000          <2> 	call b_smp_lock
  1159                              <2> 
  1160 00000802 48FF042590001100    <2> 	inc qword [os_net_TXPackets]
  1161 0000080A 48010C2588001100    <2> 	add qword [os_net_TXBytes], rcx
  1162 00000812 FF142530001100      <2> 	call qword [os_net_transmit]
  1163                              <2> 
  1164 00000819 B80C021100          <2> 	mov rax, os_NetLock
  1165 0000081E E86D010000          <2> 	call b_smp_unlock
  1166                              <2> 
  1167                              <2> b_net_tx_fail:
  1168 00000823 58                  <2> 	pop rax
  1169 00000824 59                  <2> 	pop rcx
  1170 00000825 C3                  <2> 	ret
  1171                              <2> ; -----------------------------------------------------------------------------
  1172                              <2> 
  1173                              <2> 
  1174                              <2> ; -----------------------------------------------------------------------------
  1175                              <2> ; b_net_rx -- Polls the network for received data
  1176                              <2> ;  IN:	RDI = Memory location where packet will be stored
  1177                              <2> ; OUT:	RCX = Length of packet, 0 if no data
  1178                              <2> ;	All other registers preserved
  1179                              <2> b_net_rx:
  1180 00000826 57                  <2> 	push rdi
  1181 00000827 56                  <2> 	push rsi
  1182 00000828 50                  <2> 	push rax
  1183                              <2> 
  1184 00000829 31C9                <2> 	xor ecx, ecx
  1185                              <2> 
  1186 0000082B 803C250803110001    <2> 	cmp byte [os_NetEnabled], 1
  1187 00000833 751B                <2> 	jne b_net_rx_fail
  1188                              <2> 
  1189 00000835 BE00001400          <2> 	mov rsi, os_EthernetBuffer
  1190 0000083A 668B06              <2> 	mov ax, word [rsi]		; Grab the packet length
  1191 0000083D 6685C0              <2> 	test ax, ax			; Anything there?
  1192 00000840 740E                <2> 	jz b_net_rx_fail		; If not, bail out
  1193 00000842 66890E              <2> 	mov word [rsi], cx		; Clear the packet length
  1194 00000845 6689C1              <2> 	mov cx, ax			; Save the count
  1195 00000848 4883C602            <2> 	add rsi, 2			; Skip the packet length word
  1196 0000084C 51                  <2> 	push rcx
  1197 0000084D F3A4                <2> 	rep movsb
  1198 0000084F 59                  <2> 	pop rcx
  1199                              <2> 
  1200                              <2> b_net_rx_fail:
  1201                              <2> 
  1202 00000850 58                  <2> 	pop rax
  1203 00000851 5E                  <2> 	pop rsi
  1204 00000852 5F                  <2> 	pop rdi
  1205 00000853 C3                  <2> 	ret
  1206                              <2> ; -----------------------------------------------------------------------------
  1207                              <2> 
  1208                              <2> 
  1209                              <2> ; -----------------------------------------------------------------------------
  1210                              <2> ; b_net_ack_int -- Acknowledge an interrupt within the NIC
  1211                              <2> ;  IN:	Nothing
  1212                              <2> ; OUT:	RAX = Type of interrupt trigger
  1213                              <2> ;	All other registers preserved
  1214                              <2> b_net_ack_int:
  1215 00000854 FF142540001100      <2> 	call qword [os_net_ackint]
  1216                              <2> 
  1217 0000085B C3                  <2> 	ret
  1218                              <2> ; -----------------------------------------------------------------------------
  1219                              <2> 
  1220                              <2> 
  1221                              <2> ; -----------------------------------------------------------------------------
  1222                              <2> ; b_net_rx_from_interrupt -- Polls the network for received data
  1223                              <2> ;  IN:	RDI = Memory location where packet will be stored
  1224                              <2> ; OUT:	RCX = Length of packet
  1225                              <2> ;	All other registers preserved
  1226                              <2> b_net_rx_from_interrupt:
  1227 0000085C FF142538001100      <2> 	call qword [os_net_poll]
  1228 00000863 48830425A000110001  <2> 	add qword [os_net_RXPackets], 1
  1229 0000086C 48010C2598001100    <2> 	add qword [os_net_RXBytes], rcx
  1230                              <2> 
  1231 00000874 C3                  <2> 	ret
  1232                              <2> ; -----------------------------------------------------------------------------
  1233                              <2> 
  1234                              <2> 
  1235                              <2> ; =============================================================================
  1236                              <2> ; EOF
  1237                              <1> %include "syscalls/pci.asm"
  1238                              <2> ; =============================================================================
  1239                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1240                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1241                              <2> ;
  1242                              <2> ; PCI Functions
  1243                              <2> ; =============================================================================
  1244                              <2> 
  1245                              <2> 
  1246                              <2> ; -----------------------------------------------------------------------------
  1247                              <2> ; b_pci_read_config --Read PCI configuration data.
  1248                              <2> ; IN:	RDI = bus index
  1249                              <2> ;    	RSI = device index
  1250                              <2> ;    	RDX = function index
  1251                              <2> ;    	RCX = offset
  1252                              <2> ; OUT:	RAX a 16-bit word containing the configuration data.
  1253                              <2> ;     	All other registers preserved
  1254                              <2> b_pci_read_config:
  1255                              <2> 
  1256 00000875 57                  <2> 	push rdi	; preserve the bus index
  1257 00000876 56                  <2> 	push rsi	; preserve the device index
  1258 00000877 52                  <2> 	push rdx	; preserve the function index
  1259 00000878 51                  <2> 	push rcx	; preserve the offset
  1260 00000879 4150                <2> 	push r8		; preserve r8, used for the 'enable bit'
  1261                              <2> 
  1262 0000087B 48C1E710            <2> 	shl rdi, 16	; shift the bus index
  1263 0000087F 48C1E60B            <2> 	shl rsi, 11	; shift the device index
  1264 00000883 48C1E208            <2> 	shl rdx, 8	; shift the function index
  1265 00000887 4881E1FC000000      <2> 	and rcx, 0xfc	; discard lower bits of offset
  1266 0000088E 41B800000080        <2> 	mov r8, 0x80000000 ; r8 contains the 'enable bit'
  1267                              <2> 
  1268 00000894 31C0                <2> 	xor eax, eax	; put the config address into eax
  1269 00000896 09F8                <2> 	or eax, edi	; or the bus index
  1270 00000898 09F0                <2> 	or eax, esi	; or the device index
  1271 0000089A 09D0                <2> 	or eax, edx	; or the function index
  1272 0000089C 09C8                <2> 	or eax, ecx	; or the offset
  1273 0000089E 4409C0              <2> 	or eax, r8d	; or the 'enable bit'
  1274                              <2> 
  1275 000008A1 66BAF80C            <2> 	mov dx, 0x0CF8	; move PCI config address into port register
  1276 000008A5 EF                  <2> 	out dx, eax	; write PCI config data
  1277                              <2> 
  1278 000008A6 66BAFC0C            <2> 	mov dx, 0x0CFC	; move PCI config data address into port register
  1279 000008AA ED                  <2> 	in eax, dx	; read PCI data
  1280                              <2> 
  1281 000008AB 83E102              <2> 	and ecx, 0x02	; shift the higher word of eax if needed
  1282 000008AE C1E103              <2> 	shl ecx, 0x03	; turn ecx into a bit value (multiply by 8)
  1283 000008B1 D3E8                <2> 	shr eax, cl	; shift output data by bit count in ecx
  1284 000008B3 25FFFF0000          <2> 	and eax, 0xffff ; make sure only 16 bits of data is contained by eax
  1285                              <2> 
  1286 000008B8 4158                <2> 	pop r8		; restore r8
  1287 000008BA 59                  <2> 	pop rcx		; restore offset
  1288 000008BB 5A                  <2> 	pop rdx		; restore function index
  1289 000008BC 5E                  <2> 	pop rsi		; restore device index
  1290 000008BD 5F                  <2> 	pop rdi		; restore bus index
  1291                              <2> 
  1292 000008BE C3                  <2> 	ret
  1293                              <2> ; -----------------------------------------------------------------------------
  1294                              <2> 
  1295                              <2> 
  1296                              <2> ; =============================================================================
  1297                              <2> ; EOF
  1298                              <1> %include "syscalls/smp.asm"
  1299                              <2> ; =============================================================================
  1300                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1301                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1302                              <2> ;
  1303                              <2> ; SMP Functions
  1304                              <2> ; =============================================================================
  1305                              <2> 
  1306                              <2> 
  1307                              <2> ; -----------------------------------------------------------------------------
  1308                              <2> ; b_smp_reset -- Resets a CPU Core
  1309                              <2> ;  IN:	AL = CPU #
  1310                              <2> ; OUT:	Nothing. All registers preserved.
  1311                              <2> ; Note:	This code resets an AP for set-up use only.
  1312                              <2> b_smp_reset:
  1313 000008BF 57                  <2> 	push rdi
  1314 000008C0 50                  <2> 	push rax
  1315                              <2> 
  1316 000008C1 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
  1317 000008C9 C1E018              <2> 	shl eax, 24		; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
  1318 000008CC 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
  1319 000008D2 31C0                <2> 	xor eax, eax		; Clear EAX, namely bits 31:24
  1320 000008D4 B081                <2> 	mov al, 0x81		; Execute interrupt 0x81
  1321 000008D6 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
  1322                              <2> 
  1323 000008DC 58                  <2> 	pop rax
  1324 000008DD 5F                  <2> 	pop rdi
  1325 000008DE C3                  <2> 	ret
  1326                              <2> ; -----------------------------------------------------------------------------
  1327                              <2> 
  1328                              <2> 
  1329                              <2> ; -----------------------------------------------------------------------------
  1330                              <2> ; b_smp_wakeup -- Wake up a CPU Core
  1331                              <2> ;  IN:	AL = CPU #
  1332                              <2> ; OUT:	Nothing. All registers preserved.
  1333                              <2> b_smp_wakeup:
  1334 000008DF 57                  <2> 	push rdi
  1335 000008E0 50                  <2> 	push rax
  1336                              <2> 
  1337 000008E1 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
  1338 000008E9 C1E018              <2> 	shl eax, 24		; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
  1339 000008EC 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
  1340 000008F2 31C0                <2> 	xor eax, eax		; Clear EAX, namely bits 31:24
  1341 000008F4 B080                <2> 	mov al, 0x80		; Execute interrupt 0x80
  1342 000008F6 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
  1343                              <2> 
  1344 000008FC 58                  <2> 	pop rax
  1345 000008FD 5F                  <2> 	pop rdi
  1346 000008FE C3                  <2> 	ret
  1347                              <2> ; -----------------------------------------------------------------------------
  1348                              <2> 
  1349                              <2> 
  1350                              <2> ; -----------------------------------------------------------------------------
  1351                              <2> ; b_smp_wakeup_all -- Wake up all CPU Cores
  1352                              <2> ;  IN:	Nothing.
  1353                              <2> ; OUT:	Nothing. All registers preserved.
  1354                              <2> b_smp_wakeup_all:
  1355 000008FF 57                  <2> 	push rdi
  1356 00000900 50                  <2> 	push rax
  1357                              <2> 
  1358 00000901 488B3C2500001100    <2> 	mov rdi, [os_LocalAPICAddress]
  1359 00000909 31C0                <2> 	xor eax, eax
  1360 0000090B 898710030000        <2> 	mov [rdi+0x0310], eax	; Write to the high bits first
  1361 00000911 B880000C00          <2> 	mov eax, 0x000C0080	; Execute interrupt 0x80
  1362 00000916 898700030000        <2> 	mov [rdi+0x0300], eax	; Then write to the low bits
  1363                              <2> 
  1364 0000091C 58                  <2> 	pop rax
  1365 0000091D 5F                  <2> 	pop rdi
  1366 0000091E C3                  <2> 	ret
  1367                              <2> ; -----------------------------------------------------------------------------
  1368                              <2> 
  1369                              <2> 
  1370                              <2> ; -----------------------------------------------------------------------------
  1371                              <2> ; b_smp_get_id -- Returns the APIC ID of the CPU that ran this function
  1372                              <2> ;  IN:	Nothing
  1373                              <2> ; OUT:	RAX = CPU's APIC ID number, All other registers preserved.
  1374                              <2> b_smp_get_id:
  1375 0000091F 56                  <2> 	push rsi
  1376                              <2> 
  1377 00000920 31C0                <2> 	xor eax, eax
  1378 00000922 488B342500001100    <2> 	mov rsi, [os_LocalAPICAddress]
  1379 0000092A 4883C620            <2> 	add rsi, 0x20		; Add the offset for the APIC ID location
  1380 0000092E AD                  <2> 	lodsd			; APIC ID is stored in bits 31:24
  1381 0000092F 48C1E818            <2> 	shr rax, 24		; AL now holds the CPU's APIC ID (0 - 255)
  1382                              <2> 
  1383 00000933 5E                  <2> 	pop rsi
  1384 00000934 C3                  <2> 	ret
  1385                              <2> ; -----------------------------------------------------------------------------
  1386                              <2> 
  1387                              <2> 
  1388                              <2> ; -----------------------------------------------------------------------------
  1389                              <2> ; b_smp_set -- Set a specific CPU to run code
  1390                              <2> ;  IN:	RAX = Code address
  1391                              <2> ;	RDX = Data address
  1392                              <2> ;	RCX = CPU APIC ID
  1393                              <2> ; OUT:	RAX = 0 on error
  1394                              <2> b_smp_set:
  1395 00000935 57                  <2> 	push rdi
  1396 00000936 51                  <2> 	push rcx
  1397                              <2> 
  1398 00000937 BF00F01F00          <2> 	mov rdi, os_cpu_work_table
  1399 0000093C 48C1E104            <2> 	shl rcx, 4		; Quick multiply by 16
  1400 00000940 4801CF              <2> 	add rdi, rcx		; Add the offset
  1401                              <2> 
  1402 00000943 488B0F              <2> 	mov rcx, [rdi]		; Load current code address for that core
  1403 00000946 4883F900            <2> 	cmp rcx, 0
  1404 0000094A 7513                <2> 	jne b_smp_set_error	; Bail out if the core is already set
  1405                              <2> 
  1406 0000094C 488907              <2> 	mov [rdi+0x0], rax	; Store code address
  1407 0000094F 48895708            <2> 	mov [rdi+0x8], rdx	; Store data address
  1408                              <2> 
  1409 00000953 59                  <2> 	pop rcx			; Restore the APIC ID
  1410 00000954 4891                <2> 	xchg rax, rcx
  1411 00000956 E884FFFFFF          <2> 	call b_smp_wakeup	; Wake up the core
  1412 0000095B 4891                <2> 	xchg rax, rcx
  1413                              <2> 
  1414 0000095D 5F                  <2> 	pop rdi
  1415 0000095E C3                  <2> 	ret
  1416                              <2> 
  1417                              <2> b_smp_set_error:
  1418 0000095F 31C0                <2> 	xor eax, eax		; Return 0 for error
  1419 00000961 59                  <2> 	pop rcx
  1420 00000962 5F                  <2> 	pop rdi
  1421 00000963 C3                  <2> 	ret
  1422                              <2> ; -----------------------------------------------------------------------------
  1423                              <2> 
  1424                              <2> 
  1425                              <2> ; -----------------------------------------------------------------------------
  1426                              <2> ; b_smp_get_work -- Returns a workload from the work table
  1427                              <2> ;  IN:	Nothing
  1428                              <2> ; OUT:	RAX = Code addresss
  1429                              <2> ;	RDX = Variable address
  1430                              <2> b_smp_get_work:
  1431 00000964 56                  <2> 	push rsi
  1432                              <2> 
  1433 00000965 E8B5FFFFFF          <2> 	call b_smp_get_id	; Return APIC ID in RAX
  1434                              <2> 
  1435 0000096A BE00F01F00          <2> 	mov rsi, os_cpu_work_table
  1436 0000096F 48C1E004            <2> 	shl rax, 4		; Quick multiply by 16
  1437 00000973 4801C6              <2> 	add rsi, rax		; Add the offset
  1438 00000976 488B06              <2> 	mov rax, [rsi+0x0]	; Load code address
  1439 00000979 488B5608            <2> 	mov rdx, [rsi+0x8]	; Load data address
  1440                              <2> 
  1441 0000097D 5E                  <2> 	pop rsi
  1442 0000097E C3                  <2> 	ret
  1443                              <2> ; -----------------------------------------------------------------------------
  1444                              <2> 
  1445                              <2> 
  1446                              <2> ; -----------------------------------------------------------------------------
  1447                              <2> ; b_smp_config -- Just a stub for now
  1448                              <2> ;  IN:	Nothing
  1449                              <2> ; OUT:	Nothing. All registers preserved.
  1450                              <2> b_smp_config:
  1451 0000097F C3                  <2> 	ret
  1452                              <2> ; -----------------------------------------------------------------------------
  1453                              <2> 
  1454                              <2> 
  1455                              <2> ; -----------------------------------------------------------------------------
  1456                              <2> ; b_smp_lock -- Attempt to lock a mutex
  1457                              <2> ;  IN:	RAX = Address of lock variable
  1458                              <2> ; OUT:	Nothing. All registers preserved.
  1459                              <2> b_smp_lock:
  1460 00000980 660FBA2000          <2> 	bt word [rax], 0	; Check if the mutex is free (Bit 0 cleared to 0)
  1461 00000985 72F9                <2> 	jc b_smp_lock		; If not check it again
  1462 00000987 F0660FBA2800        <2> 	lock bts word [rax], 0	; The mutex was free, lock the bus. Try to grab the mutex
  1463 0000098D 72F1                <2> 	jc b_smp_lock		; Jump if we were unsuccessful
  1464 0000098F C3                  <2> 	ret			; Lock acquired. Return to the caller
  1465                              <2> ; -----------------------------------------------------------------------------
  1466                              <2> 
  1467                              <2> 
  1468                              <2> ; -----------------------------------------------------------------------------
  1469                              <2> ; b_smp_unlock -- Unlock a mutex
  1470                              <2> ;  IN:	RAX = Address of lock variable
  1471                              <2> ; OUT:	Nothing. All registers preserved.
  1472                              <2> b_smp_unlock:
  1473 00000990 660FBA3000          <2> 	btr word [rax], 0	; Release the lock (Bit 0 cleared to 0)
  1474 00000995 C3                  <2> 	ret			; Lock released. Return to the caller
  1475                              <2> ; -----------------------------------------------------------------------------
  1476                              <2> 
  1477                              <2> 
  1478                              <2> ; =============================================================================
  1479                              <2> ; EOF
  1480                              <1> 
  1481                              <1> 
  1482                              <1> ; =============================================================================
  1483                              <1> ; EOF
  1484                                  %include "drivers.asm"
  1485                              <1> ; =============================================================================
  1486                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1487                              <1> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1488                              <1> ;
  1489                              <1> ; Driver Includes
  1490                              <1> ; =============================================================================
  1491                              <1> 
  1492                              <1> 
  1493                              <1> ; Internal
  1494                              <1> %include "drivers/pci.asm"
  1495                              <2> ; =============================================================================
  1496                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1497                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1498                              <2> ;
  1499                              <2> ; PCI Functions
  1500                              <2> ; =============================================================================
  1501                              <2> 
  1502                              <2> 
  1503                              <2> ; -----------------------------------------------------------------------------
  1504                              <2> ; os_pci_read_reg -- Read from a register on a PCI device
  1505                              <2> ;  IN:	BL  = Bus number
  1506                              <2> ;	CL  = Device/Slot/Function number
  1507                              <2> ;	DL  = Register number (0-15)
  1508                              <2> ; OUT:	EAX = Register information
  1509                              <2> ;	All other registers preserved
  1510                              <2> os_pci_read_reg:
  1511 00000996 52                  <2> 	push rdx
  1512 00000997 51                  <2> 	push rcx
  1513 00000998 53                  <2> 	push rbx
  1514                              <2> 
  1515 00000999 C1E310              <2> 	shl ebx, 16			; Move Bus number to bits 23 - 16
  1516 0000099C C1E108              <2> 	shl ecx, 8			; Move Device/Slot/Fuction number to bits 15 - 8
  1517 0000099F 6689CB              <2> 	mov bx, cx
  1518 000009A2 C1E202              <2> 	shl edx, 2
  1519 000009A5 88D3                <2> 	mov bl, dl
  1520 000009A7 81E3FFFFFF00        <2> 	and ebx, 0x00ffffff		; Clear bits 31 - 24
  1521 000009AD 81CB00000080        <2> 	or ebx, 0x80000000		; Set bit 31
  1522 000009B3 89D8                <2> 	mov eax, ebx
  1523 000009B5 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
  1524 000009B9 EF                  <2> 	out dx, eax
  1525 000009BA 66BAFC0C            <2> 	mov dx, PCI_CONFIG_DATA
  1526 000009BE ED                  <2> 	in eax, dx
  1527                              <2> 
  1528 000009BF 5B                  <2> 	pop rbx
  1529 000009C0 59                  <2> 	pop rcx
  1530 000009C1 5A                  <2> 	pop rdx
  1531 000009C2 C3                  <2> 	ret
  1532                              <2> ; -----------------------------------------------------------------------------
  1533                              <2> 
  1534                              <2> 
  1535                              <2> ; -----------------------------------------------------------------------------
  1536                              <2> ; os_pci_write_reg -- Write to a register on a PCI device
  1537                              <2> ;  IN:	BL  = Bus number
  1538                              <2> ;	CL  = Device/Slot/Function number
  1539                              <2> ;	DL  = Register number (0-15)
  1540                              <2> ; OUT:	EAX = Register information
  1541                              <2> ;	All other registers preserved
  1542                              <2> os_pci_write_reg:
  1543 000009C3 52                  <2> 	push rdx
  1544 000009C4 51                  <2> 	push rcx
  1545 000009C5 53                  <2> 	push rbx
  1546 000009C6 50                  <2> 	push rax
  1547                              <2> 
  1548 000009C7 C1E310              <2> 	shl ebx, 16			; Move Bus number to bits 23 - 16
  1549 000009CA C1E108              <2> 	shl ecx, 8			; Move Device/Slot/Fuction number to bits 15 - 8
  1550 000009CD 6689CB              <2> 	mov bx, cx
  1551 000009D0 C1E202              <2> 	shl edx, 2
  1552 000009D3 88D3                <2> 	mov bl, dl
  1553 000009D5 81E3FFFFFF00        <2> 	and ebx, 0x00ffffff		; Clear bits 31 - 24
  1554 000009DB 81CB00000080        <2> 	or ebx, 0x80000000		; Set bit 31
  1555 000009E1 89D8                <2> 	mov eax, ebx
  1556 000009E3 66BAF80C            <2> 	mov dx, PCI_CONFIG_ADDRESS
  1557 000009E7 EF                  <2> 	out dx, eax
  1558 000009E8 58                  <2> 	pop rax
  1559 000009E9 66BAFC0C            <2> 	mov dx, PCI_CONFIG_DATA
  1560 000009ED EF                  <2> 	out dx, eax
  1561                              <2> 
  1562 000009EE 5B                  <2> 	pop rbx
  1563 000009EF 59                  <2> 	pop rcx
  1564 000009F0 5A                  <2> 	pop rdx
  1565 000009F1 C3                  <2> 	ret
  1566                              <2> ; -----------------------------------------------------------------------------
  1567                              <2> 
  1568                              <2> 
  1569                              <2> ;Configuration Mechanism One has two IO port rages associated with it.
  1570                              <2> ;The address port (0xcf8-0xcfb) and the data port (0xcfc-0xcff).
  1571                              <2> ;A configuration cycle consists of writing to the address port to specify which device and register you want to access and then reading or writing the data to the data port.
  1572                              <2> 
  1573                              <2> PCI_CONFIG_ADDRESS	EQU	0x0CF8
  1574                              <2> PCI_CONFIG_DATA		EQU	0x0CFC
  1575                              <2> 
  1576                              <2> ;ddress dd 10000000000000000000000000000000b
  1577                              <2> ;          /\     /\      /\   /\ /\    /;        E    Res    Bus    Dev  F  Reg   0
  1578                              <2> ; Bits
  1579                              <2> ; 31		Enable bit = set to 1
  1580                              <2> ; 30 - 24	Reserved = set to 0
  1581                              <2> ; 23 - 16	Bus number = 256 options
  1582                              <2> ; 15 - 11	Device/Slot number = 32 options
  1583                              <2> ; 10 - 8	Function number = will leave at 0 (8 options)
  1584                              <2> ; 7 - 2		Register number = will leave at 0 (64 options) 64 x 4 bytes = 256 bytes worth of accessible registers
  1585                              <2> ; 1 - 0		Set to 0
  1586                              <2> 
  1587                              <2> 
  1588                              <2> ; =============================================================================
  1589                              <2> ; EOF
  1590                              <1> %include "drivers/pic.asm"
  1591                              <2> ; =============================================================================
  1592                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1593                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1594                              <2> ;
  1595                              <2> ; PIC Functions
  1596                              <2> ; =============================================================================
  1597                              <2> 
  1598                              <2> 
  1599                              <2> ; -----------------------------------------------------------------------------
  1600                              <2> ; os_pic_mask_clear -- Clear a mask on the PIC
  1601                              <2> ;  IN:	AL  = IRQ #
  1602                              <2> ; OUT:	All registers preserved
  1603                              <2> os_pic_mask_clear:
  1604 000009F2 6652                <2> 	push dx
  1605 000009F4 6653                <2> 	push bx
  1606 000009F6 6650                <2> 	push ax
  1607                              <2> 
  1608 000009F8 88C3                <2> 	mov bl, al			; Save the IRQ value
  1609 000009FA 80FB08              <2> 	cmp bl, 8			; Less than 8
  1610 000009FD 7C09                <2> 	jl os_pic_mask_clear_low	; If so, only set Master PIC
  1611 000009FF 66BAA100            <2> 	mov dx, 0xA1			; Slave PIC data address
  1612 00000A03 80EB08              <2> 	sub bl, 8
  1613 00000A06 EB04                <2> 	jmp os_pic_mask_clear_write
  1614                              <2> os_pic_mask_clear_low:
  1615 00000A08 66BA2100            <2> 	mov dx, 0x21			; Mast PIC data address
  1616                              <2> os_pic_mask_clear_write:
  1617 00000A0C EC                  <2> 	in al, dx			; Read the current mask
  1618 00000A0D 660FB3D8            <2> 	btr ax, bx
  1619 00000A11 EE                  <2> 	out dx, al			; Write the new mask
  1620                              <2> 
  1621 00000A12 6658                <2> 	pop ax
  1622 00000A14 665B                <2> 	pop bx
  1623 00000A16 665A                <2> 	pop dx
  1624 00000A18 C3                  <2> ret
  1625                              <2> ; -----------------------------------------------------------------------------
  1626                              <2> 
  1627                              <2> 
  1628                              <2> ; =============================================================================
  1629                              <2> ; EOF
  1630                              <1> 
  1631                              <1> ; Storage
  1632                              <1> %include "drivers/storage/ahci.asm"
  1633                              <2> ; =============================================================================
  1634                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  1635                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  1636                              <2> ;
  1637                              <2> ; AHCI Driver
  1638                              <2> ; =============================================================================
  1639                              <2> 
  1640                              <2> 
  1641                              <2> ; -----------------------------------------------------------------------------
  1642                              <2> ahci_init:
  1643                              <2> ; Probe for an AHCI hard drive controller
  1644 00000A19 31DB                <2> 	xor ebx, ebx			; Clear the Bus number
  1645 00000A1B 31C9                <2> 	xor ecx, ecx			; Clear the Device/Slot number
  1646 00000A1D BA02000000          <2> 	mov edx, 2			; Register 2 for Class code/Subclass
  1647                              <2> 
  1648                              <2> ahci_init_probe_next:
  1649 00000A22 E86FFFFFFF          <2> 	call os_pci_read_reg
  1650 00000A27 C1E810              <2> 	shr eax, 16			; Move the Class/Subclass code to AX
  1651 00000A2A 663D0601            <2> 	cmp ax, 0x0106			; Mass Storage Controller (01) / SATA Controller (06)
  1652 00000A2E 741E                <2> 	je ahci_init_found		; Found a SATA Controller
  1653 00000A30 FFC1                <2> 	inc ecx
  1654 00000A32 81F900010000        <2> 	cmp ecx, 256			; Maximum 256 devices/functions per bus
  1655 00000A38 7402                <2> 	je ahci_init_probe_next_bus
  1656 00000A3A EBE6                <2> 	jmp ahci_init_probe_next
  1657                              <2> 
  1658                              <2> ahci_init_probe_next_bus:
  1659 00000A3C 31C9                <2> 	xor ecx, ecx
  1660 00000A3E FFC3                <2> 	inc ebx
  1661 00000A40 81FB00010000        <2> 	cmp ebx, 256			; Maximum 256 buses
  1662 00000A46 0F84B9000000        <2> 	je ahci_init_error
  1663 00000A4C EBD4                <2> 	jmp ahci_init_probe_next
  1664                              <2> 
  1665                              <2> ahci_init_found:
  1666 00000A4E B209                <2> 	mov dl, 9
  1667 00000A50 31C0                <2> 	xor eax, eax
  1668 00000A52 E83FFFFFFF          <2> 	call os_pci_read_reg		; BAR5 (AHCI Base Address Register)
  1669 00000A57 4889042560001100    <2> 	mov [ahci_base], rax
  1670                              <2> 
  1671                              <2> ; Basic config of the controller, port 0
  1672 00000A5F 4889C6              <2> 	mov rsi, rax			; RSI holds the ABAR
  1673                              <2> 
  1674                              <2> ; Enable AHCI
  1675 00000A62 31C0                <2> 	xor eax, eax
  1676 00000A64 0FBAE81F            <2> 	bts eax, 31
  1677 00000A68 894604              <2> 	mov [rsi+AHCI_GHC], eax
  1678                              <2> 
  1679                              <2> ; Search the implemented ports for a drive
  1680 00000A6B 8B460C              <2> 	mov eax, [rsi+AHCI_PI]		; PI  Ports Implemented
  1681 00000A6E 89C2                <2> 	mov edx, eax
  1682 00000A70 31C9                <2> 	xor ecx, ecx
  1683 00000A72 BB28010000          <2> 	mov ebx, 0x128			; Offset to Port 0 Serial ATA Status
  1684                              <2> ahci_init_nextport:
  1685 00000A77 0FBAE200            <2> 	bt edx, 0			; Valid port?
  1686 00000A7B 7307                <2> 	jnc ahci_init_nodrive
  1687 00000A7D 8B041E              <2> 	mov eax, [rsi+rbx]
  1688 00000A80 85C0                <2> 	test eax, eax
  1689 00000A82 7511                <2> 	jnz ahci_init_founddrive
  1690                              <2> 
  1691                              <2> ahci_init_nodrive:
  1692 00000A84 FFC1                <2> 	inc ecx
  1693 00000A86 D1EA                <2> 	shr edx, 1
  1694 00000A88 81C380000000        <2> 	add ebx, 0x80			; Each port has a 128 byte memory space
  1695 00000A8E 83F920              <2> 	cmp ecx, 32
  1696 00000A91 7472                <2> 	je ahci_init_error
  1697 00000A93 EBE2                <2> 	jmp ahci_init_nextport
  1698                              <2> 
  1699                              <2> ; Configure the first port found with a drive attached
  1700                              <2> ahci_init_founddrive:
  1701 00000A95 890C250C011100      <2> 	mov [ahci_port], ecx
  1702 00000A9C 4889F7              <2> 	mov rdi, rsi
  1703 00000A9F 4881C700010000      <2> 	add rdi, 0x100			; Offset to port 0
  1704 00000AA6 51                  <2> 	push rcx			; Save port number
  1705 00000AA7 48C1E107            <2> 	shl rcx, 7			; Quick multiply by 0x80
  1706 00000AAB 4801CF              <2> 	add rdi, rcx
  1707                              <2> 
  1708 00000AAE 8B4718              <2> 	mov eax, [rdi+AHCI_PxCMD]	; Stop the port
  1709 00000AB1 0FBAF004            <2> 	btr eax, 4			; FRE
  1710 00000AB5 0FBAF000            <2> 	btr eax, 0			; ST
  1711 00000AB9 894718              <2> 	mov [rdi+AHCI_PxCMD], eax
  1712                              <2> 
  1713 00000ABC 31C0                <2> 	xor eax, eax
  1714 00000ABE 894738              <2> 	mov [rdi+AHCI_PxCI], eax	; Clear all command slots
  1715                              <2> 
  1716 00000AC1 B800000700          <2> 	mov rax, ahci_cmdlist		; 1024 bytes per port
  1717 00000AC6 AB                  <2> 	stosd				; Offset 00h: PxCLB  Port x Command List Base Address
  1718 00000AC7 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
  1719 00000ACB AB                  <2> 	stosd				; Offset 04h: PxCLBU  Port x Command List Base Address Upper 32-bits
  1720 00000ACC B800100700          <2> 	mov rax, ahci_receivedfis	; 256 or 4096 bytes per port
  1721 00000AD1 AB                  <2> 	stosd				; Offset 08h: PxFB  Port x FIS Base Address
  1722 00000AD2 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
  1723 00000AD6 AB                  <2> 	stosd				; Offset 0Ch: PxFBU  Port x FIS Base Address Upper 32-bits
  1724 00000AD7 AB                  <2> 	stosd				; Offset 10h: PxIS  Port x Interrupt Status
  1725 00000AD8 AB                  <2> 	stosd				; Offset 14h: PxIE  Port x Interrupt Enable
  1726                              <2> 
  1727                              <2> 	; Query drive
  1728 00000AD9 59                  <2> 	pop rcx				; Restore port number
  1729 00000ADA BF00001900          <2> 	mov rdi, os_temp
  1730 00000ADF 4889FE              <2> 	mov rsi, rdi
  1731 00000AE2 E81F000000          <2> 	call ahci_id
  1732 00000AE7 8B86C8000000        <2> 	mov eax, [rsi+200]		; Max LBA Extended
  1733 00000AED 48C1E80B            <2> 	shr rax, 11			; rax = rax * 512 / 1048576	MiB
  1734                              <2> ;	shr rax, 21			; rax = rax * 512 / 1073741824	GiB
  1735 00000AF1 89042510011100      <2> 	mov [hd1_size], eax		; in mebibytes (MiB)
  1736                              <2> 
  1737 00000AF8 83F800              <2> 	cmp eax, 0
  1738 00000AFB 7408                <2> 	je ahci_init_error
  1739                              <2> 
  1740                              <2> 	; Found a bootable drive
  1741 00000AFD C604250F03110001    <2> 	mov byte [os_DiskEnabled], 0x01
  1742                              <2> 
  1743                              <2> ahci_init_error:
  1744 00000B05 C3                  <2> 	ret
  1745                              <2> ; -----------------------------------------------------------------------------
  1746                              <2> 
  1747                              <2> 
  1748                              <2> ; -----------------------------------------------------------------------------
  1749                              <2> ; ahci_id -- Identify a SATA drive
  1750                              <2> ; IN:	RCX = Port # to query
  1751                              <2> ;	RDI = memory location to store details (512 bytes)
  1752                              <2> ; OUT:	Nothing, all registers preserved
  1753                              <2> ahci_id:
  1754 00000B06 57                  <2> 	push rdi
  1755 00000B07 56                  <2> 	push rsi
  1756 00000B08 51                  <2> 	push rcx
  1757 00000B09 50                  <2> 	push rax
  1758 00000B0A 57                  <2> 	push rdi			; Save the destination memory address
  1759                              <2> 
  1760 00000B0B 488B342560001100    <2> 	mov rsi, [ahci_base]
  1761 00000B13 48C1E107            <2> 	shl rcx, 7			; Quick multiply by 0x80
  1762 00000B17 4881C100010000      <2> 	add rcx, 0x100			; Offset to port 0
  1763 00000B1E 4801CE              <2> 	add rsi, rcx
  1764                              <2> 
  1765                              <2> 	; Build the Command List Header
  1766 00000B21 BF00000700          <2> 	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)
  1767 00000B26 B805000100          <2> 	mov eax, 0x00010005		; 1 PRDTL Entry, Command FIS Length = 20 bytes
  1768 00000B2B AB                  <2> 	stosd				; DW 0 - Description Information
  1769 00000B2C 31C0                <2> 	xor eax, eax
  1770 00000B2E AB                  <2> 	stosd				; DW 1 - Command Status
  1771 00000B2F B800200700          <2> 	mov rax, ahci_cmdtable
  1772 00000B34 AB                  <2> 	stosd				; DW 2 - Command Table Base Address
  1773 00000B35 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
  1774 00000B39 AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
  1775 00000B3A 31C0                <2> 	xor eax, eax
  1776 00000B3C 48AB                <2> 	stosq				; DW 4-7 are reserved
  1777 00000B3E 48AB                <2> 	stosq
  1778                              <2> 
  1779                              <2> 	; Build the Command Table
  1780 00000B40 BF00200700          <2> 	mov rdi, ahci_cmdtable		; Build a command table for Port 0
  1781 00000B45 B82780EC00          <2> 	mov eax, 0x00EC8027		; EC identify, bit 15 set, fis 27 H2D
  1782 00000B4A AB                  <2> 	stosd				; feature 7:0, command, c, fis
  1783 00000B4B 31C0                <2> 	xor eax, eax
  1784 00000B4D 48AB                <2> 	stosq				; the rest of the table can be clear
  1785 00000B4F 48AB                <2> 	stosq
  1786                              <2> 
  1787                              <2> 	; PRDT - pysical region descriptor table
  1788 00000B51 BF80200700          <2> 	mov rdi, ahci_cmdtable + 0x80
  1789 00000B56 58                  <2> 	pop rax				; Restore the destination memory address
  1790 00000B57 AB                  <2> 	stosd				; Data Base Address
  1791 00000B58 48C1E820            <2> 	shr rax, 32
  1792 00000B5C AB                  <2> 	stosd				; Data Base Address Upper
  1793 00000B5D 31C0                <2> 	xor eax, eax
  1794 00000B5F AB                  <2> 	stosd				; Reserved
  1795 00000B60 B8FF010000          <2> 	mov eax, 0x000001FF		; 512 - 1
  1796 00000B65 AB                  <2> 	stosd				; Description Information
  1797                              <2> 
  1798 00000B66 31C0                <2> 	xor eax, eax
  1799 00000B68 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
  1800                              <2> 
  1801 00000B6B B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
  1802 00000B70 894638              <2> 	mov [rsi+AHCI_PxCI], eax
  1803                              <2> 
  1804 00000B73 31C0                <2> 	xor eax, eax
  1805 00000B75 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
  1806 00000B79 0FBAE800            <2> 	bts eax, 0			; Start (ST)
  1807 00000B7D 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
  1808                              <2> 
  1809                              <2> ahci_id_poll:
  1810 00000B80 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]	; Read Command Slot 0 status
  1811 00000B83 85C0                <2> 	test eax, eax
  1812 00000B85 75F9                <2> 	jnz ahci_id_poll
  1813                              <2> 
  1814 00000B87 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
  1815 00000B8A 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
  1816 00000B8E 0FBAF000            <2> 	btr eax, 0			; Start (ST)
  1817 00000B92 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
  1818                              <2> 
  1819 00000B95 58                  <2> 	pop rax
  1820 00000B96 59                  <2> 	pop rcx
  1821 00000B97 5E                  <2> 	pop rsi
  1822 00000B98 5F                  <2> 	pop rdi
  1823 00000B99 C3                  <2> 	ret
  1824                              <2> ; -----------------------------------------------------------------------------
  1825                              <2> 
  1826                              <2> 
  1827                              <2> ; -----------------------------------------------------------------------------
  1828                              <2> ; ahci_read -- Read data from a SATA hard drive
  1829                              <2> ; IN:	RAX = starting sector # to read (48-bit LBA address)
  1830                              <2> ;	RCX = number of sectors to read (up to 8192 = 4MiB)
  1831                              <2> ;	RDX = disk #
  1832                              <2> ;	RDI = memory location to store sectors
  1833                              <2> ; OUT:	RAX = RAX + number of sectors that were read
  1834                              <2> ;	RCX = number of sectors that were read (0 on error)
  1835                              <2> ;	RDI = RDI + (number of sectors read * 512)
  1836                              <2> ;	All other registers preserved
  1837                              <2> ahci_read:
  1838 00000B9A 52                  <2> 	push rdx
  1839 00000B9B 53                  <2> 	push rbx
  1840 00000B9C 57                  <2> 	push rdi
  1841 00000B9D 56                  <2> 	push rsi
  1842 00000B9E 51                  <2> 	push rcx
  1843 00000B9F 50                  <2> 	push rax
  1844                              <2> 
  1845 00000BA0 51                  <2> 	push rcx			; Save the sector count
  1846 00000BA1 57                  <2> 	push rdi			; Save the destination memory address
  1847 00000BA2 50                  <2> 	push rax			; Save the block number
  1848 00000BA3 50                  <2> 	push rax
  1849                              <2> 
  1850 00000BA4 488B342560001100    <2> 	mov rsi, [ahci_base]
  1851 00000BAC 48C1E207            <2> 	shl rdx, 7			; Quick multiply by 0x80
  1852 00000BB0 4881C200010000      <2> 	add rdx, 0x100			; Offset to port 0
  1853 00000BB7 4801D6              <2> 	add rsi, rdx
  1854                              <2> 
  1855                              <2> 	; Build the Command List Header
  1856 00000BBA BF00000700          <2> 	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)
  1857 00000BBF 31C0                <2> 	xor eax, eax
  1858 00000BC1 B805000100          <2> 	mov eax, 0x00010005		; 1 PRDTL Entry, Command FIS Length = 20 bytes
  1859 00000BC6 AB                  <2> 	stosd				; DW 0 - Description Information
  1860 00000BC7 31C0                <2> 	xor eax, eax
  1861 00000BC9 AB                  <2> 	stosd				; DW 1 - Command Status
  1862 00000BCA B800200700          <2> 	mov eax, ahci_cmdtable
  1863 00000BCF AB                  <2> 	stosd				; DW 2 - Command Table Base Address
  1864 00000BD0 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
  1865 00000BD4 AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
  1866 00000BD5 31C0                <2> 	xor eax, eax
  1867 00000BD7 48AB                <2> 	stosq				; DW 4 - 7 are reserved
  1868 00000BD9 48AB                <2> 	stosq
  1869                              <2> 
  1870                              <2> 	; Build the Command Table
  1871 00000BDB BF00200700          <2> 	mov rdi, ahci_cmdtable		; Build a command table for Port 0
  1872 00000BE0 B827802500          <2> 	mov eax, 0x00258027		; 25 READ DMA EXT, bit 15 set, fis 27 H2D
  1873 00000BE5 AB                  <2> 	stosd				; feature 7:0, command, c, fis
  1874 00000BE6 58                  <2> 	pop rax				; Restore the start sector number
  1875 00000BE7 48C1E024            <2> 	shl rax, 36
  1876 00000BEB 48C1E824            <2> 	shr rax, 36			; Upper 36 bits cleared
  1877 00000BEF 480FBAE81E          <2> 	bts rax, 30			; bit 30 set for LBA
  1878 00000BF4 AB                  <2> 	stosd				; device, lba 23:16, lba 15:8, lba 7:0
  1879 00000BF5 58                  <2> 	pop rax				; Restore the start sector number
  1880 00000BF6 48C1E818            <2> 	shr rax, 24
  1881 00000BFA AB                  <2> 	stosd				; feature 15:8, lba 47:40, lba 39:32, lba 31:24
  1882 00000BFB 4889C8              <2> 	mov rax, rcx			; Read the number of sectors given in rcx
  1883 00000BFE AB                  <2> 	stosd				; control, ICC, count 15:8, count 7:0
  1884 00000BFF 31C0                <2> 	xor eax, eax
  1885 00000C01 AB                  <2> 	stosd				; reserved
  1886                              <2> 
  1887                              <2> 	; PRDT setup
  1888 00000C02 BF80200700          <2> 	mov rdi, ahci_cmdtable + 0x80
  1889 00000C07 58                  <2> 	pop rax				; Restore the destination memory address
  1890 00000C08 AB                  <2> 	stosd				; Data Base Address
  1891 00000C09 48C1E820            <2> 	shr rax, 32
  1892 00000C0D AB                  <2> 	stosd				; Data Base Address Upper
  1893 00000C0E 31C0                <2> 	xor eax, eax
  1894 00000C10 AB                  <2> 	stosd				; Reserved
  1895 00000C11 58                  <2> 	pop rax				; Restore the sector count
  1896 00000C12 48C1E009            <2> 	shl rax, 9			; multiply by 512 for bytes
  1897 00000C16 48FFC8              <2> 	dec rax				; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
  1898 00000C19 AB                  <2> 	stosd				; Description Information
  1899                              <2> 
  1900 00000C1A 31C0                <2> 	xor eax, eax
  1901 00000C1C 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
  1902                              <2> 
  1903 00000C1F B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
  1904 00000C24 894638              <2> 	mov [rsi+AHCI_PxCI], eax
  1905                              <2> 
  1906 00000C27 31C0                <2> 	xor eax, eax
  1907 00000C29 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
  1908 00000C2D 0FBAE800            <2> 	bts eax, 0			; Start (ST)
  1909 00000C31 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
  1910                              <2> 
  1911                              <2> ahci_read_poll:
  1912 00000C34 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]
  1913 00000C37 85C0                <2> 	test eax, eax
  1914 00000C39 75F9                <2> 	jnz ahci_read_poll
  1915                              <2> 
  1916 00000C3B 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
  1917 00000C3E 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
  1918 00000C42 0FBAF000            <2> 	btr eax, 0			; Start (ST)
  1919 00000C46 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
  1920                              <2> 
  1921 00000C49 58                  <2> 	pop rax				; rax = start
  1922 00000C4A 59                  <2> 	pop rcx				; rcx = number of sectors read
  1923 00000C4B 4801C8              <2> 	add rax, rcx			; rax = start + number of sectors read
  1924 00000C4E 5E                  <2> 	pop rsi
  1925 00000C4F 5F                  <2> 	pop rdi
  1926 00000C50 4889CB              <2> 	mov rbx, rcx			; rdi = dest addr + number of bytes read
  1927 00000C53 48C1E309            <2> 	shl rbx, 9
  1928 00000C57 4801DF              <2> 	add rdi, rbx
  1929 00000C5A 5B                  <2> 	pop rbx
  1930 00000C5B 5A                  <2> 	pop rdx
  1931 00000C5C C3                  <2> 	ret
  1932                              <2> ; -----------------------------------------------------------------------------
  1933                              <2> 
  1934                              <2> 
  1935                              <2> ; -----------------------------------------------------------------------------
  1936                              <2> ; ahci_write -- Write data to a SATA hard drive
  1937                              <2> ; IN:	RAX = starting sector # to write (48-bit LBA Address)
  1938                              <2> ;	RCX = number of sectors to write (up to 8192 = 4MiB)
  1939                              <2> ;	RDX = disk #
  1940                              <2> ;	RSI = memory location of sectors
  1941                              <2> ; OUT:	RAX = RAX + number of sectors that were written
  1942                              <2> ;	RCX = number of sectors that were written (0 on error)
  1943                              <2> ;	RSI = RSI + (number of sectors written * 512)
  1944                              <2> ;	All other registers preserved
  1945                              <2> ahci_write:
  1946 00000C5D 52                  <2> 	push rdx
  1947 00000C5E 53                  <2> 	push rbx
  1948 00000C5F 57                  <2> 	push rdi
  1949 00000C60 56                  <2> 	push rsi
  1950 00000C61 51                  <2> 	push rcx
  1951 00000C62 50                  <2> 	push rax
  1952                              <2> 
  1953 00000C63 51                  <2> 	push rcx			; Save the sector count
  1954 00000C64 56                  <2> 	push rsi			; Save the source memory address
  1955 00000C65 50                  <2> 	push rax			; Save the block number
  1956 00000C66 50                  <2> 	push rax
  1957                              <2> 
  1958 00000C67 488B342560001100    <2> 	mov rsi, [ahci_base]
  1959 00000C6F 48C1E207            <2> 	shl rdx, 7			; Quick multiply by 0x80
  1960 00000C73 4881C200010000      <2> 	add rdx, 0x100			; Offset to port 0
  1961 00000C7A 4801D6              <2> 	add rsi, rdx
  1962                              <2> 
  1963                              <2> 	; Build the Command List Header
  1964 00000C7D BF00000700          <2> 	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)
  1965 00000C82 31C0                <2> 	xor eax, eax
  1966 00000C84 B845000100          <2> 	mov eax, 0x00010045		; 1 PRDTL Entry, write flag (bit 6), Command FIS Length = 20 bytes
  1967 00000C89 AB                  <2> 	stosd				; DW 0 - Description Information
  1968 00000C8A 31C0                <2> 	xor eax, eax
  1969 00000C8C AB                  <2> 	stosd				; DW 1 - Command Status
  1970 00000C8D B800200700          <2> 	mov rax, ahci_cmdtable
  1971 00000C92 AB                  <2> 	stosd				; DW 2 - Command Table Base Address
  1972 00000C93 48C1E820            <2> 	shr rax, 32			; 63..32 bits of address
  1973 00000C97 AB                  <2> 	stosd				; DW 3 - Command Table Base Address Upper
  1974 00000C98 31C0                <2> 	xor eax, eax
  1975 00000C9A 48AB                <2> 	stosq				; DW 4 - 7 are reserved
  1976 00000C9C 48AB                <2> 	stosq
  1977                              <2> 
  1978                              <2> 	; Build the Command Table
  1979 00000C9E BF00200700          <2> 	mov rdi, ahci_cmdtable		; Build a command table for Port 0
  1980 00000CA3 B827803500          <2> 	mov eax, 0x00358027		; 35 WRITE DMA EXT, bit 15 set, fis 27 H2D
  1981 00000CA8 AB                  <2> 	stosd				; feature 7:0, command, c, fis
  1982 00000CA9 58                  <2> 	pop rax				; Restore the start sector number
  1983 00000CAA 48C1E024            <2> 	shl rax, 36
  1984 00000CAE 48C1E824            <2> 	shr rax, 36			; Upper 36 bits cleared
  1985 00000CB2 480FBAE81E          <2> 	bts rax, 30			; bit 30 set for LBA
  1986 00000CB7 AB                  <2> 	stosd				; device, lba 23:16, lba 15:8, lba 7:0
  1987 00000CB8 58                  <2> 	pop rax				; Restore the start sector number
  1988 00000CB9 48C1E818            <2> 	shr rax, 24
  1989 00000CBD AB                  <2> 	stosd				; feature 15:8, lba 47:40, lba 39:32, lba 31:24
  1990 00000CBE 4889C8              <2> 	mov rax, rcx			; Read the number of sectors given in rcx
  1991 00000CC1 AB                  <2> 	stosd				; control, ICC, count 15:8, count 7:0
  1992 00000CC2 31C0                <2> 	xor eax, eax
  1993 00000CC4 AB                  <2> 	stosd				; reserved
  1994                              <2> 
  1995                              <2> 	; PRDT setup
  1996 00000CC5 BF80200700          <2> 	mov rdi, ahci_cmdtable + 0x80
  1997 00000CCA 58                  <2> 	pop rax				; Restore the source memory address
  1998 00000CCB AB                  <2> 	stosd				; Data Base Address
  1999 00000CCC 48C1E820            <2> 	shr rax, 32
  2000 00000CD0 AB                  <2> 	stosd				; Data Base Address Upper
  2001 00000CD1 31C0                <2> 	xor eax, eax
  2002 00000CD3 AB                  <2> 	stosd				; Reserved
  2003 00000CD4 58                  <2> 	pop rax				; Restore the sector count
  2004 00000CD5 48C1E009            <2> 	shl rax, 9			; multiply by 512 for bytes
  2005 00000CD9 48FFC8              <2> 	dec rax				; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
  2006 00000CDC AB                  <2> 	stosd				; Description Information
  2007                              <2> 
  2008 00000CDD 31C0                <2> 	xor eax, eax
  2009 00000CDF 894610              <2> 	mov [rsi+AHCI_PxIS], eax	; Port x Interrupt Status
  2010                              <2> 
  2011 00000CE2 B801000000          <2> 	mov eax, 0x00000001		; Execute Command Slot 0
  2012 00000CE7 894638              <2> 	mov [rsi+AHCI_PxCI], eax
  2013                              <2> 
  2014 00000CEA 31C0                <2> 	xor eax, eax
  2015 00000CEC 0FBAE804            <2> 	bts eax, 4			; FIS Recieve Enable (FRE)
  2016 00000CF0 0FBAE800            <2> 	bts eax, 0			; Start (ST)
  2017 00000CF4 894618              <2> 	mov [rsi+AHCI_PxCMD], eax	; Offset to port 0 Command and Status
  2018                              <2> 
  2019                              <2> ahci_write_poll:
  2020 00000CF7 8B4638              <2> 	mov eax, [rsi+AHCI_PxCI]
  2021 00000CFA 85C0                <2> 	test eax, eax
  2022 00000CFC 75F9                <2> 	jnz ahci_write_poll
  2023                              <2> 
  2024 00000CFE 8B4618              <2> 	mov eax, [rsi+AHCI_PxCMD]	; Offset to port 0
  2025 00000D01 0FBAF004            <2> 	btr eax, 4			; FIS Receive Enable (FRE)
  2026 00000D05 0FBAF000            <2> 	btr eax, 0			; Start (ST)
  2027 00000D09 894618              <2> 	mov [rsi+AHCI_PxCMD], eax
  2028                              <2> 
  2029 00000D0C 58                  <2> 	pop rax				; rax = start
  2030 00000D0D 59                  <2> 	pop rcx				; rcx = number of sectors read
  2031 00000D0E 4801C8              <2> 	add rax, rcx			; rax = start + number of sectors written
  2032 00000D11 5E                  <2> 	pop rsi
  2033 00000D12 5F                  <2> 	pop rdi
  2034 00000D13 4889CB              <2> 	mov rbx, rcx			; rdi = dest addr + number of bytes written
  2035 00000D16 48C1E309            <2> 	shl rbx, 9
  2036 00000D1A 4801DF              <2> 	add rdi, rbx
  2037 00000D1D 5B                  <2> 	pop rbx
  2038 00000D1E 5A                  <2> 	pop rdx
  2039 00000D1F C3                  <2> 	ret
  2040                              <2> ; -----------------------------------------------------------------------------
  2041                              <2> 
  2042                              <2> 
  2043                              <2> ; HBA Memory Registers
  2044                              <2> ; 0x0000 - 0x002B	Generic Host Control
  2045                              <2> ; 0x002C - 0x005F	Reserved
  2046                              <2> ; 0x0060 - 0x009F	Reserved for NVMHCI
  2047                              <2> ; 0x00A0 - 0x00FF	Vendor Specific Registers
  2048                              <2> ; 0x0100 - 0x017F	Port 0
  2049                              <2> ; 0x0180 - 0x01FF	Port 1
  2050                              <2> ; ...
  2051                              <2> ; 0x1000 - 0x107F	Port 30
  2052                              <2> ; 0x1080 - 0x10FF	Port 31
  2053                              <2> 
  2054                              <2> ; Generic Host Control
  2055                              <2> AHCI_CAP		equ 0x0000 ; HBA Capabilities
  2056                              <2> AHCI_GHC		equ 0x0004 ; Global HBA Control
  2057                              <2> AHCI_IS			equ 0x0008 ; Interrupt Status Register
  2058                              <2> AHCI_PI			equ 0x000C ; Ports Implemented
  2059                              <2> AHCI_VS			equ 0x0010 ; AHCI Version
  2060                              <2> AHCI_CCC_CTL		equ 0x0014 ; Command Completion Coalescing Control
  2061                              <2> AHCI_CCC_PORTS		equ 0x0018 ; Command Completion Coalescing Ports
  2062                              <2> AHCI_EM_LOC		equ 0x001C ; Enclosure Management Location
  2063                              <2> AHCI_EM_CTL		equ 0x0020 ; Enclosure Management Control
  2064                              <2> AHCI_CAP2		equ 0x0024 ; HBA Capabilities Extended
  2065                              <2> AHCI_BOHC		equ 0x0028 ; BIOS/OS Handoff Control and Status
  2066                              <2> 
  2067                              <2> ; Port Registers
  2068                              <2> ; Port 0 starts at 100h, port 1 starts at 180h, port 2 starts at 200h, port 3 at 280h, etc.
  2069                              <2> AHCI_PxCLB		equ 0x0000 ; Port x Command List Base Address
  2070                              <2> AHCI_PxCLBU		equ 0x0004 ; Port x Command List Base Address Upper 32-bits
  2071                              <2> AHCI_PxFB		equ 0x0008 ; Port x FIS Base Address
  2072                              <2> AHCI_PxFBU		equ 0x000C ; Port x FIS Base Address Upper 32-bits
  2073                              <2> AHCI_PxIS		equ 0x0010 ; Port x Interrupt Status
  2074                              <2> AHCI_PxIE		equ 0x0014 ; Port x Interrupt Enable
  2075                              <2> AHCI_PxCMD		equ 0x0018 ; Port x Command and Status
  2076                              <2> AHCI_PxTFD		equ 0x0020 ; Port x Task File Data
  2077                              <2> AHCI_PxSIG		equ 0x0024 ; Port x Signature
  2078                              <2> AHCI_PxSSTS		equ 0x0028 ; Port x Serial ATA Status (SCR0: SStatus)
  2079                              <2> AHCI_PxSCTL		equ 0x002C ; Port x Serial ATA Control (SCR2: SControl)
  2080                              <2> AHCI_PxSERR		equ 0x0030 ; Port x Serial ATA Error (SCR1: SError)
  2081                              <2> AHCI_PxSACT		equ 0x0034 ; Port x Serial ATA Active (SCR3: SActive)
  2082                              <2> AHCI_PxCI		equ 0x0038 ; Port x Command Issue
  2083                              <2> AHCI_PxSNTF		equ 0x003C ; Port x Serial ATA Notification (SCR4: SNotification)
  2084                              <2> AHCI_PxFBS		equ 0x0040 ; Port x FIS-based Switching Control
  2085                              <2> AHCI_PxDEVSLP		equ 0x0044 ; Port x Device Sleep
  2086                              <2> ; 0x0048 - 0x006F	Reserved
  2087                              <2> ; 0x0070 - 0x007F	Port x Vendor Specific
  2088                              <2> 
  2089                              <2> 
  2090                              <2> ; =============================================================================
  2091                              <2> ; EOF
  2092                              <1> 
  2093                              <1> ; Network
  2094                              <1> %include "drivers/net/i8254x.asm"
  2095                              <2> ; =============================================================================
  2096                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  2097                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  2098                              <2> ;
  2099                              <2> ; Intel i8254x Driver
  2100                              <2> ; =============================================================================
  2101                              <2> 
  2102                              <2> 
  2103                              <2> ; -----------------------------------------------------------------------------
  2104                              <2> ; Initialize an Intel 8254x NIC
  2105                              <2> ;  IN:	BL  = Bus number of the Intel device
  2106                              <2> ;	CL  = Device/Slot number of the Intel device
  2107                              <2> net_i8254x_init:
  2108 00000D20 56                  <2> 	push rsi
  2109 00000D21 52                  <2> 	push rdx
  2110 00000D22 51                  <2> 	push rcx
  2111 00000D23 50                  <2> 	push rax
  2112                              <2> 
  2113                              <2> 	; Read BAR4, If BAR4 is all 0'z then we are using 32-bit addresses
  2114                              <2> 
  2115                              <2> 	; Grab the Base I/O Address of the device
  2116 00000D24 B204                <2> 	mov dl, 0x04				; BAR0
  2117 00000D26 E86BFCFFFF          <2> 	call os_pci_read_reg
  2118 00000D2B 83E0F0              <2> 	and eax, 0xFFFFFFF0			; EAX now holds the Base Memory IO Address (clear the low 4 bits)
  2119 00000D2E 89042548001100      <2> 	mov dword [os_NetIOBaseMem], eax
  2120                              <2> 
  2121                              <2> 	; Grab the IRQ of the device
  2122 00000D35 B20F                <2> 	mov dl, 0x0F				; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
  2123 00000D37 E85AFCFFFF          <2> 	call os_pci_read_reg
  2124 00000D3C 8804250A031100      <2> 	mov [os_NetIRQ], al			; AL holds the IRQ
  2125                              <2> 
  2126                              <2> 	; Enable PCI Bus Mastering
  2127 00000D43 B201                <2> 	mov dl, 0x01				; Get Status/Command
  2128 00000D45 E84CFCFFFF          <2> 	call os_pci_read_reg
  2129 00000D4A 0FBAE802            <2> 	bts eax, 2
  2130 00000D4E E870FCFFFF          <2> 	call os_pci_write_reg
  2131                              <2> 
  2132                              <2> 	; Grab the MAC address
  2133 00000D53 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
  2134 00000D5B 8B8600540000        <2> 	mov eax, [rsi+0x5400]			; RAL
  2135 00000D61 83F800              <2> 	cmp eax, 0x00000000
  2136 00000D64 743E                <2> 	je net_i8254x_init_get_MAC_via_EPROM
  2137 00000D66 88042550001100      <2> 	mov [os_NetMAC], al
  2138 00000D6D C1E808              <2> 	shr eax, 8
  2139 00000D70 88042551001100      <2> 	mov [os_NetMAC+1], al
  2140 00000D77 C1E808              <2> 	shr eax, 8
  2141 00000D7A 88042552001100      <2> 	mov [os_NetMAC+2], al
  2142 00000D81 C1E808              <2> 	shr eax, 8
  2143 00000D84 88042553001100      <2> 	mov [os_NetMAC+3], al
  2144 00000D8B 8B8604540000        <2> 	mov eax, [rsi+0x5404]			; RAH
  2145 00000D91 88042554001100      <2> 	mov [os_NetMAC+4], al
  2146 00000D98 C1E808              <2> 	shr eax, 8
  2147 00000D9B 88042555001100      <2> 	mov [os_NetMAC+5], al
  2148 00000DA2 EB65                <2> 	jmp net_i8254x_init_done_MAC
  2149                              <2> 
  2150                              <2> net_i8254x_init_get_MAC_via_EPROM:
  2151 00000DA4 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
  2152 00000DAC B801000000          <2> 	mov eax, 0x00000001
  2153 00000DB1 894614              <2> 	mov [rsi+0x14], eax
  2154 00000DB4 8B4614              <2> 	mov eax, [rsi+0x14]
  2155 00000DB7 C1E810              <2> 	shr eax, 16
  2156 00000DBA 88042550001100      <2> 	mov [os_NetMAC], al
  2157 00000DC1 C1E808              <2> 	shr eax, 8
  2158 00000DC4 88042551001100      <2> 	mov [os_NetMAC+1], al
  2159 00000DCB B801010000          <2> 	mov eax, 0x00000101
  2160 00000DD0 894614              <2> 	mov [rsi+0x14], eax
  2161 00000DD3 8B4614              <2> 	mov eax, [rsi+0x14]
  2162 00000DD6 C1E810              <2> 	shr eax, 16
  2163 00000DD9 88042552001100      <2> 	mov [os_NetMAC+2], al
  2164 00000DE0 C1E808              <2> 	shr eax, 8
  2165 00000DE3 88042553001100      <2> 	mov [os_NetMAC+3], al
  2166 00000DEA B801020000          <2> 	mov eax, 0x00000201
  2167 00000DEF 894614              <2> 	mov [rsi+0x14], eax
  2168 00000DF2 8B4614              <2> 	mov eax, [rsi+0x14]
  2169 00000DF5 C1E810              <2> 	shr eax, 16
  2170 00000DF8 88042554001100      <2> 	mov [os_NetMAC+4], al
  2171 00000DFF C1E808              <2> 	shr eax, 8
  2172 00000E02 88042555001100      <2> 	mov [os_NetMAC+5], al
  2173                              <2> net_i8254x_init_done_MAC:
  2174                              <2> 
  2175                              <2> 	; Reset the device
  2176 00000E09 E805000000          <2> 	call net_i8254x_reset
  2177                              <2> 
  2178 00000E0E 58                  <2> 	pop rax
  2179 00000E0F 59                  <2> 	pop rcx
  2180 00000E10 5A                  <2> 	pop rdx
  2181 00000E11 5E                  <2> 	pop rsi
  2182 00000E12 C3                  <2> 	ret
  2183                              <2> ; -----------------------------------------------------------------------------
  2184                              <2> 
  2185                              <2> 
  2186                              <2> ; -----------------------------------------------------------------------------
  2187                              <2> ; net_i8254x_reset - Reset an Intel 8254x NIC
  2188                              <2> ;  IN:	Nothing
  2189                              <2> ; OUT:	Nothing, all registers preserved
  2190                              <2> net_i8254x_reset:
  2191 00000E13 57                  <2> 	push rdi
  2192 00000E14 56                  <2> 	push rsi
  2193 00000E15 50                  <2> 	push rax
  2194                              <2> 
  2195 00000E16 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
  2196 00000E1E 4889F7              <2> 	mov rdi, rsi
  2197                              <2> 
  2198 00000E21 B8FFFFFFFF          <2> 	mov eax, 0xFFFFFFFF
  2199 00000E26 8986D8000000        <2> 	mov [rsi+I8254X_REG_IMC], eax		; Disable all interrupt causes
  2200 00000E2C 8B86C0000000        <2> 	mov eax, [rsi+I8254X_REG_ICR]		; Clear any pending interrupts
  2201 00000E32 31C0                <2> 	xor eax, eax
  2202 00000E34 8986C4000000        <2> 	mov [rsi+I8254X_REG_ITR], eax		; Disable interrupt throttling logic
  2203                              <2> 
  2204 00000E3A B830000000          <2> 	mov eax, 0x00000030
  2205 00000E3F 898600100000        <2> 	mov [rsi+I8254X_REG_PBA], eax		; PBA: set the RX buffer size to 48KB (TX buffer is calculated as 64-RX buffer)
  2206                              <2> 
  2207 00000E45 B860800080          <2> 	mov eax, 0x80008060
  2208 00000E4A 898678010000        <2> 	mov [rsi+I8254X_REG_TXCW], eax		; TXCW: set ANE, TxConfigWord (Half/Full duplex, Next Page Request)
  2209                              <2> 
  2210 00000E50 8B06                <2> 	mov eax, [rsi+I8254X_REG_CTRL]
  2211 00000E52 0FBAF003            <2> 	btr eax, 3				; LRST = 0
  2212 00000E56 0FBAE806            <2> 	bts eax, 6				; SLU = 1
  2213 00000E5A 0FBAE805            <2> 	bts eax, 5				; ASDE = 1
  2214 00000E5E 0FBAF01F            <2> 	btr eax, 31				; PHY_RST = 0
  2215 00000E62 0FBAF01E            <2> 	btr eax, 30				; VME = 0 (Disable 802.1Q)
  2216 00000E66 0FBAF007            <2> 	btr eax, 7				; ILOS = 0
  2217 00000E6A 8906                <2> 	mov [rsi+I8254X_REG_CTRL], eax		; CTRL: clear LRST, set SLU and ASDE, clear RSTPHY, VME, and ILOS
  2218                              <2> 
  2219 00000E6C 57                  <2> 	push rdi
  2220 00000E6D 4881C700520000      <2> 	add rdi, I8254X_REG_MTA			; MTA: reset
  2221 00000E74 B8FFFFFFFF          <2> 	mov eax, 0xFFFFFFFF
  2222 00000E79 AB                  <2> 	stosd
  2223 00000E7A AB                  <2> 	stosd
  2224 00000E7B AB                  <2> 	stosd
  2225 00000E7C AB                  <2> 	stosd
  2226 00000E7D 5F                  <2> 	pop rdi
  2227                              <2> 
  2228 00000E7E B800001A00          <2> 	mov rax, os_rx_desc
  2229 00000E83 898600280000        <2> 	mov [rsi+I8254X_REG_RDBAL], eax		; Receive Descriptor Base Address Low
  2230 00000E89 48C1E820            <2> 	shr rax, 32
  2231 00000E8D 898604280000        <2> 	mov [rsi+I8254X_REG_RDBAH], eax		; Receive Descriptor Base Address High
  2232 00000E93 B800010000          <2> 	mov eax, (32 * 8)			; Multiples of 8, each desciptor is 16 bytes
  2233 00000E98 898608280000        <2> 	mov [rsi+I8254X_REG_RDLEN], eax		; Receive Descriptor Length
  2234 00000E9E 31C0                <2> 	xor eax, eax
  2235 00000EA0 898610280000        <2> 	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head
  2236 00000EA6 B801000000          <2> 	mov eax, 1
  2237 00000EAB 898618280000        <2> 	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail
  2238 00000EB1 B806800004          <2> 	mov eax, 0x04008006			; Receiver Enable, Store Bad Packets, Broadcast Accept Mode, Strip Ethernet CRC from incoming packet
  2239 00000EB6 898600010000        <2> 	mov [rsi+I8254X_REG_RCTL], eax		; Receive Control Register
  2240                              <2> 
  2241 00000EBC 57                  <2> 	push rdi
  2242 00000EBD BF00001A00          <2> 	mov rdi, os_rx_desc
  2243 00000EC2 B800901C00          <2> 	mov rax, 0x1c9000			; Packet will go here
  2244 00000EC7 AB                  <2> 	stosd
  2245 00000EC8 5F                  <2> 	pop rdi
  2246                              <2> 
  2247 00000EC9 B800801A00          <2> 	mov rax, os_tx_desc
  2248 00000ECE 898600380000        <2> 	mov [rsi+I8254X_REG_TDBAL], eax		; Transmit Descriptor Base Address Low
  2249 00000ED4 48C1E820            <2> 	shr rax, 32
  2250 00000ED8 898604380000        <2> 	mov [rsi+I8254X_REG_TDBAH], eax		; Transmit Descriptor Base Address High
  2251 00000EDE B800010000          <2> 	mov eax, (32 * 8)			; Multiples of 8, each desciptor is 16 bytes
  2252 00000EE3 898608380000        <2> 	mov [rsi+I8254X_REG_TDLEN], eax		; Transmit Descriptor Length
  2253 00000EE9 31C0                <2> 	xor eax, eax
  2254 00000EEB 898610380000        <2> 	mov [rsi+I8254X_REG_TDH], eax		; Transmit Descriptor Head
  2255 00000EF1 898618380000        <2> 	mov [rsi+I8254X_REG_TDT], eax		; Transmit Descriptor Tail
  2256 00000EF7 B8FA000401          <2> 	mov eax, 0x010400FA			; Enabled, Pad Short Packets, 15 retries, 64-byte COLD, Re-transmit on Late Collision
  2257 00000EFC 898600040000        <2> 	mov [rsi+I8254X_REG_TCTL], eax		; Transmit Control Register
  2258 00000F02 B80A206000          <2> 	mov eax, 0x0060200A			; IPGT 10, IPGR1 8, IPGR2 6
  2259 00000F07 898610040000        <2> 	mov [rsi+I8254X_REG_TIPG], eax		; Transmit IPG Register
  2260                              <2> 
  2261 00000F0D 31C0                <2> 	xor eax, eax
  2262 00000F0F 898620280000        <2> 	mov [rsi+I8254X_REG_RDTR], eax		; Clear the Receive Delay Timer Register
  2263 00000F15 89862C280000        <2> 	mov [rsi+I8254X_REG_RADV], eax		; Clear the Receive Interrupt Absolute Delay Timer
  2264 00000F1B 8986002C0000        <2> 	mov [rsi+I8254X_REG_RSRPD], eax		; Clear the Receive Small Packet Detect Interrupt
  2265                              <2> 
  2266 00000F21 B8FFFF0100          <2> 	mov eax, 0x1FFFF			; Temp enable all interrupt types
  2267 00000F26 8986D0000000        <2> 	mov [rsi+I8254X_REG_IMS], eax		; Enable interrupt types
  2268                              <2> 
  2269 00000F2C 58                  <2> 	pop rax
  2270 00000F2D 5E                  <2> 	pop rsi
  2271 00000F2E 5F                  <2> 	pop rdi
  2272 00000F2F C3                  <2> 	ret
  2273                              <2> ; -----------------------------------------------------------------------------
  2274                              <2> 
  2275                              <2> 
  2276                              <2> ; -----------------------------------------------------------------------------
  2277                              <2> ; net_i8254x_transmit - Transmit a packet via an Intel 8254x NIC
  2278                              <2> ;  IN:	RSI = Location of packet
  2279                              <2> ;	RCX = Length of packet
  2280                              <2> ; OUT:	Nothing
  2281                              <2> net_i8254x_transmit:
  2282 00000F30 57                  <2> 	push rdi
  2283 00000F31 50                  <2> 	push rax
  2284                              <2> 
  2285 00000F32 BF00801A00          <2> 	mov rdi, os_tx_desc			; Transmit Descriptor Base Address
  2286 00000F37 4889F0              <2> 	mov rax, rsi
  2287 00000F3A 48AB                <2> 	stosq					; Store the data location
  2288 00000F3C 4889C8              <2> 	mov rax, rcx				; The packet size is in CX
  2289 00000F3F 480FBAE818          <2> 	bts rax, 24				; EOP
  2290 00000F44 480FBAE819          <2> 	bts rax, 25				; IFCS
  2291 00000F49 480FBAE81B          <2> 	bts rax, 27				; RS
  2292 00000F4E 48AB                <2> 	stosq
  2293 00000F50 488B3C2548001100    <2> 	mov rdi, [os_NetIOBaseMem]
  2294 00000F58 31C0                <2> 	xor eax, eax
  2295 00000F5A 898710380000        <2> 	mov [rdi+I8254X_REG_TDH], eax		; TDH - Transmit Descriptor Head
  2296 00000F60 FFC0                <2> 	inc eax
  2297 00000F62 898718380000        <2> 	mov [rdi+I8254X_REG_TDT], eax		; TDL - Transmit Descriptor Tail
  2298                              <2> 
  2299 00000F68 58                  <2> 	pop rax
  2300 00000F69 5F                  <2> 	pop rdi
  2301 00000F6A C3                  <2> 	ret
  2302                              <2> ; -----------------------------------------------------------------------------
  2303                              <2> 
  2304                              <2> 
  2305                              <2> ; -----------------------------------------------------------------------------
  2306                              <2> ; net_i8254x_poll - Polls the Intel 8254x NIC for a received packet
  2307                              <2> ;  IN:	RDI = Location to store packet
  2308                              <2> ; OUT:	RCX = Length of packet
  2309                              <2> net_i8254x_poll:
  2310 00000F6B 57                  <2> 	push rdi
  2311 00000F6C 56                  <2> 	push rsi
  2312 00000F6D 50                  <2> 	push rax
  2313                              <2> 
  2314 00000F6E 31C9                <2> 	xor ecx, ecx
  2315 00000F70 668B0C2508001A00    <2> 	mov cx, [os_rx_desc+8]			; Get the packet length
  2316 00000F78 BE00901C00          <2> 	mov rsi, 0x1c9000
  2317 00000F7D 51                  <2> 	push rcx
  2318 00000F7E F3A4                <2> 	rep movsb
  2319 00000F80 59                  <2> 	pop rcx
  2320 00000F81 488B342548001100    <2> 	mov rsi, [os_NetIOBaseMem]
  2321 00000F89 31C0                <2> 	xor eax, eax
  2322 00000F8B 898610280000        <2> 	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head
  2323 00000F91 FFC0                <2> 	inc eax
  2324 00000F93 898618280000        <2> 	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail
  2325                              <2> 
  2326 00000F99 BF00001A00          <2> 	mov rdi, os_rx_desc
  2327 00000F9E B800901C00          <2> 	mov rax, 0x1c9000			; Packet will go here
  2328 00000FA3 AB                  <2> 	stosd
  2329                              <2> 
  2330 00000FA4 58                  <2> 	pop rax
  2331 00000FA5 5E                  <2> 	pop rsi
  2332 00000FA6 5F                  <2> 	pop rdi
  2333 00000FA7 C3                  <2> 	ret
  2334                              <2> ; -----------------------------------------------------------------------------
  2335                              <2> 
  2336                              <2> 
  2337                              <2> ; -----------------------------------------------------------------------------
  2338                              <2> ; net_i8254x_ack_int - Acknowledge an internal interrupt of the Intel 8254x NIC
  2339                              <2> ;  IN:	Nothing
  2340                              <2> ; OUT:	RAX = Ethernet status
  2341                              <2> net_i8254x_ack_int:
  2342 00000FA8 57                  <2> 	push rdi
  2343                              <2> 
  2344 00000FA9 31C0                <2> 	xor eax, eax
  2345 00000FAB 488B3C2548001100    <2> 	mov rdi, [os_NetIOBaseMem]
  2346 00000FB3 8B87C0000000        <2> 	mov eax, [rdi+I8254X_REG_ICR]
  2347                              <2> 
  2348 00000FB9 5F                  <2> 	pop rdi
  2349 00000FBA C3                  <2> 	ret
  2350                              <2> ; -----------------------------------------------------------------------------
  2351                              <2> 
  2352                              <2> 
  2353                              <2> ; Maximum packet size
  2354                              <2> I8254X_MAX_PKT_SIZE	equ 16384
  2355                              <2> 
  2356                              <2> ; Register list
  2357                              <2> I8254X_REG_CTRL		equ 0x0000 ; Control Register
  2358                              <2> I8254X_REG_STATUS	equ 0x0008 ; Device Status Register
  2359                              <2> I8254X_REG_CTRLEXT	equ 0x0018 ; Extended Control Register
  2360                              <2> I8254X_REG_MDIC		equ 0x0020 ; MDI Control Register
  2361                              <2> I8254X_REG_FCAL		equ 0x0028 ; Flow Control Address Low
  2362                              <2> I8254X_REG_FCAH		equ 0x002C ; Flow Control Address High
  2363                              <2> I8254X_REG_FCT		equ 0x0030 ; Flow Control Type
  2364                              <2> I8254X_REG_VET		equ 0x0038 ; VLAN Ether Type
  2365                              <2> I8254X_REG_ICR		equ 0x00C0 ; Interrupt Cause Read
  2366                              <2> I8254X_REG_ITR		equ 0x00C4 ; Interrupt Throttling Register
  2367                              <2> I8254X_REG_ICS		equ 0x00C8 ; Interrupt Cause Set Register
  2368                              <2> I8254X_REG_IMS		equ 0x00D0 ; Interrupt Mask Set/Read Register
  2369                              <2> I8254X_REG_IMC		equ 0x00D8 ; Interrupt Mask Clear Register
  2370                              <2> I8254X_REG_RCTL		equ 0x0100 ; Receive Control Register
  2371                              <2> I8254X_REG_FCTTV	equ 0x0170 ; Flow Control Transmit Timer Value
  2372                              <2> I8254X_REG_TXCW		equ 0x0178 ; Transmit Configuration Word
  2373                              <2> I8254X_REG_RXCW		equ 0x0180 ; Receive Configuration Word
  2374                              <2> I8254X_REG_TCTL		equ 0x0400 ; Transmit Control Register
  2375                              <2> I8254X_REG_TIPG		equ 0x0410 ; Transmit Inter Packet Gap
  2376                              <2> 
  2377                              <2> I8254X_REG_LEDCTL	equ 0x0E00 ; LED Control
  2378                              <2> I8254X_REG_PBA		equ 0x1000 ; Packet Buffer Allocation
  2379                              <2> 
  2380                              <2> I8254X_REG_RDBAL	equ 0x2800 ; RX Descriptor Base Address Low
  2381                              <2> I8254X_REG_RDBAH	equ 0x2804 ; RX Descriptor Base Address High
  2382                              <2> I8254X_REG_RDLEN	equ 0x2808 ; RX Descriptor Length
  2383                              <2> I8254X_REG_RDH		equ 0x2810 ; RX Descriptor Head
  2384                              <2> I8254X_REG_RDT		equ 0x2818 ; RX Descriptor Tail
  2385                              <2> I8254X_REG_RDTR		equ 0x2820 ; RX Delay Timer Register
  2386                              <2> I8254X_REG_RXDCTL	equ 0x3828 ; RX Descriptor Control
  2387                              <2> I8254X_REG_RADV		equ 0x282C ; RX Int. Absolute Delay Timer
  2388                              <2> I8254X_REG_RSRPD	equ 0x2C00 ; RX Small Packet Detect Interrupt
  2389                              <2> 
  2390                              <2> I8254X_REG_TXDMAC	equ 0x3000 ; TX DMA Control
  2391                              <2> I8254X_REG_TDBAL	equ 0x3800 ; TX Descriptor Base Address Low
  2392                              <2> I8254X_REG_TDBAH	equ 0x3804 ; TX Descriptor Base Address High
  2393                              <2> I8254X_REG_TDLEN	equ 0x3808 ; TX Descriptor Length
  2394                              <2> I8254X_REG_TDH		equ 0x3810 ; TX Descriptor Head
  2395                              <2> I8254X_REG_TDT		equ 0x3818 ; TX Descriptor Tail
  2396                              <2> I8254X_REG_TIDV		equ 0x3820 ; TX Interrupt Delay Value
  2397                              <2> I8254X_REG_TXDCTL	equ 0x3828 ; TX Descriptor Control
  2398                              <2> I8254X_REG_TADV		equ 0x382C ; TX Absolute Interrupt Delay Value
  2399                              <2> I8254X_REG_TSPMT	equ 0x3830 ; TCP Segmentation Pad & Min Threshold
  2400                              <2> 
  2401                              <2> I8254X_REG_RXCSUM	equ 0x5000 ; RX Checksum Control
  2402                              <2> I8254X_REG_MTA		equ 0x5200 ; Multicast Table Array
  2403                              <2> 
  2404                              <2> ; Register list for i8254x
  2405                              <2> I82542_REG_RDTR		equ 0x0108 ; RX Delay Timer Register
  2406                              <2> I82542_REG_RDBAL	equ 0x0110 ; RX Descriptor Base Address Low
  2407                              <2> I82542_REG_RDBAH	equ 0x0114 ; RX Descriptor Base Address High
  2408                              <2> I82542_REG_RDLEN	equ 0x0118 ; RX Descriptor Length
  2409                              <2> I82542_REG_RDH		equ 0x0120 ; RDH for i82542
  2410                              <2> I82542_REG_RDT		equ 0x0128 ; RDT for i82542
  2411                              <2> I82542_REG_TDBAL	equ 0x0420 ; TX Descriptor Base Address Low
  2412                              <2> I82542_REG_TDBAH	equ 0x0424 ; TX Descriptor Base Address Low
  2413                              <2> I82542_REG_TDLEN	equ 0x0428 ; TX Descriptor Length
  2414                              <2> I82542_REG_TDH		equ 0x0430 ; TDH for i82542
  2415                              <2> I82542_REG_TDT		equ 0x0438 ; TDT for i82542
  2416                              <2> 
  2417                              <2> ; CTRL - Control Register (0x0000)
  2418                              <2> I8254X_CTRL_FD		equ 0x00000001 ; Full Duplex
  2419                              <2> I8254X_CTRL_LRST	equ 0x00000008 ; Link Reset
  2420                              <2> I8254X_CTRL_ASDE	equ 0x00000020 ; Auto-speed detection
  2421                              <2> I8254X_CTRL_SLU		equ 0x00000040 ; Set Link Up
  2422                              <2> I8254X_CTRL_ILOS	equ 0x00000080 ; Invert Loss of Signal
  2423                              <2> I8254X_CTRL_SPEED_MASK	equ 0x00000300 ; Speed selection
  2424                              <2> I8254X_CTRL_SPEED_SHIFT	equ 8
  2425                              <2> I8254X_CTRL_FRCSPD	equ 0x00000800 ; Force Speed
  2426                              <2> I8254X_CTRL_FRCDPLX	equ 0x00001000 ; Force Duplex
  2427                              <2> I8254X_CTRL_SDP0_DATA	equ 0x00040000 ; SDP0 data
  2428                              <2> I8254X_CTRL_SDP1_DATA	equ 0x00080000 ; SDP1 data
  2429                              <2> I8254X_CTRL_SDP0_IODIR	equ 0x00400000 ; SDP0 direction
  2430                              <2> I8254X_CTRL_SDP1_IODIR	equ 0x00800000 ; SDP1 direction
  2431                              <2> I8254X_CTRL_RST		equ 0x04000000 ; Device Reset
  2432                              <2> I8254X_CTRL_RFCE	equ 0x08000000 ; RX Flow Ctrl Enable
  2433                              <2> I8254X_CTRL_TFCE	equ 0x10000000 ; TX Flow Ctrl Enable
  2434                              <2> I8254X_CTRL_VME		equ 0x40000000 ; VLAN Mode Enable
  2435                              <2> I8254X_CTRL_PHY_RST	equ 0x80000000 ; PHY reset
  2436                              <2> 
  2437                              <2> ; STATUS - Device Status Register (0x0008)
  2438                              <2> I8254X_STATUS_FD		equ 0x00000001 ; Full Duplex
  2439                              <2> I8254X_STATUS_LU		equ 0x00000002 ; Link Up
  2440                              <2> I8254X_STATUS_TXOFF		equ 0x00000010 ; Transmit paused
  2441                              <2> I8254X_STATUS_TBIMODE		equ 0x00000020 ; TBI Mode
  2442                              <2> I8254X_STATUS_SPEED_MASK	equ 0x000000C0 ; Link Speed setting
  2443                              <2> I8254X_STATUS_SPEED_SHIFT	equ 6
  2444                              <2> I8254X_STATUS_ASDV_MASK		equ 0x00000300 ; Auto Speed Detection
  2445                              <2> I8254X_STATUS_ASDV_SHIFT	equ 8
  2446                              <2> I8254X_STATUS_PCI66		equ 0x00000800 ; PCI bus speed
  2447                              <2> I8254X_STATUS_BUS64		equ 0x00001000 ; PCI bus width
  2448                              <2> I8254X_STATUS_PCIX_MODE		equ 0x00002000 ; PCI-X mode
  2449                              <2> I8254X_STATUS_PCIXSPD_MASK	equ 0x0000C000 ; PCI-X speed
  2450                              <2> I8254X_STATUS_PCIXSPD_SHIFT	equ 14
  2451                              <2> 
  2452                              <2> ; CTRL_EXT - Extended Device Control Register (0x0018)
  2453                              <2> I8254X_CTRLEXT_PHY_INT		equ 0x00000020 ; PHY interrupt
  2454                              <2> I8254X_CTRLEXT_SDP6_DATA	equ 0x00000040 ; SDP6 data
  2455                              <2> I8254X_CTRLEXT_SDP7_DATA	equ 0x00000080 ; SDP7 data
  2456                              <2> I8254X_CTRLEXT_SDP6_IODIR	equ 0x00000400 ; SDP6 direction
  2457                              <2> I8254X_CTRLEXT_SDP7_IODIR	equ 0x00000800 ; SDP7 direction
  2458                              <2> I8254X_CTRLEXT_ASDCHK		equ 0x00001000 ; Auto-Speed Detect Chk
  2459                              <2> I8254X_CTRLEXT_EE_RST		equ 0x00002000 ; EEPROM reset
  2460                              <2> I8254X_CTRLEXT_SPD_BYPS		equ 0x00008000 ; Speed Select Bypass
  2461                              <2> I8254X_CTRLEXT_RO_DIS		equ 0x00020000 ; Relaxed Ordering Dis.
  2462                              <2> I8254X_CTRLEXT_LNKMOD_MASK	equ 0x00C00000 ; Link Mode
  2463                              <2> I8254X_CTRLEXT_LNKMOD_SHIFT	equ 22
  2464                              <2> 
  2465                              <2> ; MDIC - MDI Control Register (0x0020)
  2466                              <2> I8254X_MDIC_DATA_MASK	equ 0x0000FFFF ; Data
  2467                              <2> I8254X_MDIC_REG_MASK	equ 0x001F0000 ; PHY Register
  2468                              <2> I8254X_MDIC_REG_SHIFT	equ 16
  2469                              <2> I8254X_MDIC_PHY_MASK	equ 0x03E00000 ; PHY Address
  2470                              <2> I8254X_MDIC_PHY_SHIFT	equ 21
  2471                              <2> I8254X_MDIC_OP_MASK	equ 0x0C000000 ; Opcode
  2472                              <2> I8254X_MDIC_OP_SHIFT	equ 26
  2473                              <2> I8254X_MDIC_R		equ 0x10000000 ; Ready
  2474                              <2> I8254X_MDIC_I		equ 0x20000000 ; Interrupt Enable
  2475                              <2> I8254X_MDIC_E		equ 0x40000000 ; Error
  2476                              <2> 
  2477                              <2> ; ICR - Interrupt Cause Read (0x00c0)
  2478                              <2> I8254X_ICR_TXDW		equ 0x00000001 ; TX Desc Written back
  2479                              <2> I8254X_ICR_TXQE		equ 0x00000002 ; TX Queue Empty
  2480                              <2> I8254X_ICR_LSC		equ 0x00000004 ; Link Status Change
  2481                              <2> I8254X_ICR_RXSEQ	equ 0x00000008 ; RX Sequence Error
  2482                              <2> I8254X_ICR_RXDMT0	equ 0x00000010 ; RX Desc min threshold reached
  2483                              <2> I8254X_ICR_RXO		equ 0x00000040 ; RX Overrun
  2484                              <2> I8254X_ICR_RXT0		equ 0x00000080 ; RX Timer Interrupt
  2485                              <2> I8254X_ICR_MDAC		equ 0x00000200 ; MDIO Access Complete
  2486                              <2> I8254X_ICR_RXCFG	equ 0x00000400
  2487                              <2> I8254X_ICR_PHY_INT	equ 0x00001000 ; PHY Interrupt
  2488                              <2> I8254X_ICR_GPI_SDP6	equ 0x00002000 ; GPI on SDP6
  2489                              <2> I8254X_ICR_GPI_SDP7	equ 0x00004000 ; GPI on SDP7
  2490                              <2> I8254X_ICR_TXD_LOW	equ 0x00008000 ; TX Desc low threshold hit
  2491                              <2> I8254X_ICR_SRPD		equ 0x00010000 ; Small RX packet detected
  2492                              <2> 
  2493                              <2> ; RCTL - Receive Control Register (0x0100)
  2494                              <2> I8254X_RCTL_EN		equ 0x00000002 ; Receiver Enable
  2495                              <2> I8254X_RCTL_SBP		equ 0x00000004 ; Store Bad Packets
  2496                              <2> I8254X_RCTL_UPE		equ 0x00000008 ; Unicast Promiscuous Enabled
  2497                              <2> I8254X_RCTL_MPE		equ 0x00000010 ; Xcast Promiscuous Enabled
  2498                              <2> I8254X_RCTL_LPE		equ 0x00000020 ; Long Packet Reception Enable
  2499                              <2> I8254X_RCTL_LBM_MASK	equ 0x000000C0 ; Loopback Mode
  2500                              <2> I8254X_RCTL_LBM_SHIFT	equ 6
  2501                              <2> I8254X_RCTL_RDMTS_MASK	equ 0x00000300 ; RX Desc Min Threshold Size
  2502                              <2> I8254X_RCTL_RDMTS_SHIFT	equ 8
  2503                              <2> I8254X_RCTL_MO_MASK	equ 0x00003000 ; Multicast Offset
  2504                              <2> I8254X_RCTL_MO_SHIFT	equ 12
  2505                              <2> I8254X_RCTL_BAM		equ 0x00008000 ; Broadcast Accept Mode
  2506                              <2> I8254X_RCTL_BSIZE_MASK	equ 0x00030000 ; RX Buffer Size
  2507                              <2> I8254X_RCTL_BSIZE_SHIFT	equ 16
  2508                              <2> I8254X_RCTL_VFE		equ 0x00040000 ; VLAN Filter Enable
  2509                              <2> I8254X_RCTL_CFIEN	equ 0x00080000 ; CFI Enable
  2510                              <2> I8254X_RCTL_CFI		equ 0x00100000 ; Canonical Form Indicator Bit
  2511                              <2> I8254X_RCTL_DPF		equ 0x00400000 ; Discard Pause Frames
  2512                              <2> I8254X_RCTL_PMCF	equ 0x00800000 ; Pass MAC Control Frames
  2513                              <2> I8254X_RCTL_BSEX	equ 0x02000000 ; Buffer Size Extension
  2514                              <2> I8254X_RCTL_SECRC	equ 0x04000000 ; Strip Ethernet CRC
  2515                              <2> 
  2516                              <2> ; TCTL - Transmit Control Register (0x0400)
  2517                              <2> I8254X_TCTL_EN		equ 0x00000002 ; Transmit Enable
  2518                              <2> I8254X_TCTL_PSP		equ 0x00000008 ; Pad short packets
  2519                              <2> I8254X_TCTL_SWXOFF	equ 0x00400000 ; Software XOFF Transmission
  2520                              <2> 
  2521                              <2> ; PBA - Packet Buffer Allocation (0x1000)
  2522                              <2> I8254X_PBA_RXA_MASK	equ 0x0000FFFF ; RX Packet Buffer
  2523                              <2> I8254X_PBA_RXA_SHIFT	equ 0
  2524                              <2> I8254X_PBA_TXA_MASK	equ 0xFFFF0000 ; TX Packet Buffer
  2525                              <2> I8254X_PBA_TXA_SHIFT	equ 16
  2526                              <2> 
  2527                              <2> ; Flow Control Type
  2528                              <2> I8254X_FCT_TYPE_DEFAULT	equ 0x8808
  2529                              <2> 
  2530                              <2> ; === TX Descriptor fields ===
  2531                              <2> 
  2532                              <2> ; TX Packet Length (word 2)
  2533                              <2> I8254X_TXDESC_LEN_MASK	equ 0x0000ffff
  2534                              <2> 
  2535                              <2> ; TX Descriptor CMD field (word 2)
  2536                              <2> I8254X_TXDESC_IDE	equ 0x80000000 ; Interrupt Delay Enable
  2537                              <2> I8254X_TXDESC_VLE	equ 0x40000000 ; VLAN Packet Enable
  2538                              <2> I8254X_TXDESC_DEXT	equ 0x20000000 ; Extension
  2539                              <2> I8254X_TXDESC_RPS	equ 0x10000000 ; Report Packet Sent
  2540                              <2> I8254X_TXDESC_RS	equ 0x08000000 ; Report Status
  2541                              <2> I8254X_TXDESC_IC	equ 0x04000000 ; Insert Checksum
  2542                              <2> I8254X_TXDESC_IFCS	equ 0x02000000 ; Insert FCS
  2543                              <2> I8254X_TXDESC_EOP	equ 0x01000000 ; End Of Packet
  2544                              <2> 
  2545                              <2> ; TX Descriptor STA field (word 3)
  2546                              <2> I8254X_TXDESC_TU	equ 0x00000008 ; Transmit Underrun
  2547                              <2> I8254X_TXDESC_LC	equ 0x00000004 ; Late Collision
  2548                              <2> I8254X_TXDESC_EC	equ 0x00000002 ; Excess Collisions
  2549                              <2> I8254X_TXDESC_DD	equ 0x00000001 ; Descriptor Done
  2550                              <2> 
  2551                              <2> ; === RX Descriptor fields ===
  2552                              <2> 
  2553                              <2> ; RX Packet Length (word 2)
  2554                              <2> I8254X_RXDESC_LEN_MASK	equ 0x0000ffff
  2555                              <2> 
  2556                              <2> ; RX Descriptor STA field (word 3)
  2557                              <2> I8254X_RXDESC_PIF	equ 0x00000080 ; Passed In-exact Filter
  2558                              <2> I8254X_RXDESC_IPCS	equ 0x00000040 ; IP cksum calculated
  2559                              <2> I8254X_RXDESC_TCPCS	equ 0x00000020 ; TCP cksum calculated
  2560                              <2> I8254X_RXDESC_VP	equ 0x00000008 ; Packet is 802.1Q
  2561                              <2> I8254X_RXDESC_IXSM	equ 0x00000004 ; Ignore cksum indication
  2562                              <2> I8254X_RXDESC_EOP	equ 0x00000002 ; End Of Packet
  2563                              <2> I8254X_RXDESC_DD	equ 0x00000001 ; Descriptor Done
  2564                              <2> 
  2565                              <2> ; =============================================================================
  2566                              <2> ; EOF
  2567                              <1> %include "drivers/net/virtio.asm"
  2568                              <2> ; =============================================================================
  2569                              <2> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  2570                              <2> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  2571                              <2> ;
  2572                              <2> ; Virtio NIC Driver
  2573                              <2> ; =============================================================================
  2574                              <2> 
  2575                              <2> 
  2576                              <2> ; -----------------------------------------------------------------------------
  2577                              <2> ; Initialize a Virtio NIC
  2578                              <2> ;  IN:	BL  = Bus number of the Virtio device
  2579                              <2> ;	CL  = Device/Slot number of the Virtio device
  2580                              <2> net_virtio_init:
  2581 00000FBB 56                  <2> 	push rsi
  2582 00000FBC 52                  <2> 	push rdx
  2583 00000FBD 51                  <2> 	push rcx
  2584 00000FBE 50                  <2> 	push rax
  2585                              <2> 
  2586                              <2> 	; Grab the Base I/O Address of the device
  2587 00000FBF B204                <2> 	mov dl, 0x04			; BAR0
  2588 00000FC1 E8D0F9FFFF          <2> 	call os_pci_read_reg
  2589                              <2> 	; Todo: Make sure bit 0 is 1
  2590 00000FC6 83E0FC              <2> 	and eax, 0xFFFFFFFC		; Clear the low two bits
  2591 00000FC9 89042548001100      <2> 	mov dword [os_NetIOBaseMem], eax
  2592                              <2> 
  2593                              <2> 	; Grab the IRQ of the device
  2594 00000FD0 B20F                <2> 	mov dl, 0x0F			; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
  2595 00000FD2 E8BFF9FFFF          <2> 	call os_pci_read_reg
  2596 00000FD7 8804250A031100      <2> 	mov [os_NetIRQ], al		; AL holds the IRQ
  2597                              <2> 
  2598                              <2> 	; Grab the MAC address
  2599 00000FDE 8B142548001100      <2> 	mov edx, [os_NetIOBaseMem]
  2600 00000FE5 83C214              <2> 	add edx, 0x14
  2601 00000FE8 EC                  <2> 	in al, dx
  2602 00000FE9 88042550001100      <2> 	mov [os_NetMAC], al
  2603 00000FF0 66FFC2              <2> 	inc dx
  2604 00000FF3 EC                  <2> 	in al, dx
  2605 00000FF4 88042551001100      <2> 	mov [os_NetMAC+1], al
  2606 00000FFB 66FFC2              <2> 	inc dx
  2607 00000FFE EC                  <2> 	in al, dx
  2608 00000FFF 88042552001100      <2> 	mov [os_NetMAC+2], al
  2609 00001006 66FFC2              <2> 	inc dx
  2610 00001009 EC                  <2> 	in al, dx
  2611 0000100A 88042553001100      <2> 	mov [os_NetMAC+3], al
  2612 00001011 66FFC2              <2> 	inc dx
  2613 00001014 EC                  <2> 	in al, dx
  2614 00001015 88042554001100      <2> 	mov [os_NetMAC+4], al
  2615 0000101C 66FFC2              <2> 	inc dx
  2616 0000101F EC                  <2> 	in al, dx
  2617 00001020 88042555001100      <2> 	mov [os_NetMAC+5], al
  2618                              <2> 
  2619                              <2> ;	jmp $
  2620                              <2> 
  2621                              <2> 	; Reset the device
  2622 00001027 E805000000          <2> 	call net_virtio_reset
  2623                              <2> 
  2624 0000102C 58                  <2> 	pop rax
  2625 0000102D 59                  <2> 	pop rcx
  2626 0000102E 5A                  <2> 	pop rdx
  2627 0000102F 5E                  <2> 	pop rsi
  2628 00001030 C3                  <2> 	ret
  2629                              <2> ; -----------------------------------------------------------------------------
  2630                              <2> 
  2631                              <2> 
  2632                              <2> ; -----------------------------------------------------------------------------
  2633                              <2> ; net_virtio_reset - Reset a Virtio NIC
  2634                              <2> ;  IN:	Nothing
  2635                              <2> ; OUT:	Nothing, all registers preserved
  2636                              <2> net_virtio_reset:
  2637                              <2> 
  2638                              <2> 
  2639                              <2> ; Acknowledge
  2640                              <2> 
  2641                              <2> ; Driver
  2642                              <2> 
  2643                              <2> ; Queue
  2644                              <2> 
  2645 00001031 C3                  <2> 	ret
  2646                              <2> ; -----------------------------------------------------------------------------
  2647                              <2> 
  2648                              <2> 
  2649                              <2> ; -----------------------------------------------------------------------------
  2650                              <2> ; net_virtio_transmit - Transmit a packet via a Virtio NIC
  2651                              <2> ;  IN:	RSI = Location of packet
  2652                              <2> ;	RCX = Length of packet
  2653                              <2> ; OUT:	Nothing
  2654                              <2> net_virtio_transmit:
  2655                              <2> 
  2656 00001032 C3                  <2> 	ret
  2657                              <2> ; -----------------------------------------------------------------------------
  2658                              <2> 
  2659                              <2> 
  2660                              <2> ; -----------------------------------------------------------------------------
  2661                              <2> ; net_virtio_poll - Polls the Virtio NIC for a received packet
  2662                              <2> ;  IN:	RDI = Location to store packet
  2663                              <2> ; OUT:	RCX = Length of packet
  2664                              <2> net_virtio_poll:
  2665                              <2> 
  2666 00001033 C3                  <2> 	ret
  2667                              <2> ; -----------------------------------------------------------------------------
  2668                              <2> 
  2669                              <2> 
  2670                              <2> ; -----------------------------------------------------------------------------
  2671                              <2> ; net_virtio_ack_int - Acknowledge an internal interrupt of the Virtio NIC
  2672                              <2> ;  IN:	Nothing
  2673                              <2> ; OUT:	RAX = Ethernet status
  2674                              <2> ;	Uses RDI
  2675                              <2> net_virtio_ack_int:
  2676                              <2> 
  2677 00001034 C3                  <2> 	ret
  2678                              <2> ; -----------------------------------------------------------------------------
  2679                              <2> 
  2680                              <2> 
  2681                              <2> ; =============================================================================
  2682                              <2> ; EOF
  2683                              <1> 
  2684                              <1> 
  2685                              <1> NIC_DeviceVendor_ID:	; The supported list of NICs
  2686                              <1> ; The ID's are Device/Vendor
  2687                              <1> 
  2688                              <1> ; Virtio
  2689 00001035 FFFFF41A            <1> dd 0x1AF4FFFF		; Driver marker
  2690 00001039 F41A0010            <1> dd 0x10001AF4
  2691                              <1> 
  2692                              <1> ; Intel 8254x Gigabit Ethernet
  2693 0000103D FFFF5482            <1> dd 0x8254FFFF		; Driver marker
  2694 00001041 86800010            <1> dd 0x10008086		; 82542 (Fiber)
  2695 00001045 86800110            <1> dd 0x10018086		; 82543GC (Fiber)
  2696 00001049 86800410            <1> dd 0x10048086		; 82543GC (Copper)
  2697 0000104D 86800810            <1> dd 0x10088086		; 82544EI (Copper)
  2698 00001051 86800910            <1> dd 0x10098086		; 82544EI (Fiber)
  2699 00001055 86800A10            <1> dd 0x100A8086		; 82540EM
  2700 00001059 86800C10            <1> dd 0x100C8086		; 82544GC (Copper)
  2701 0000105D 86800D10            <1> dd 0x100D8086		; 82544GC (LOM)
  2702 00001061 86800E10            <1> dd 0x100E8086		; 82540EM
  2703 00001065 86800F10            <1> dd 0x100F8086		; 82545EM (Copper)
  2704 00001069 86801010            <1> dd 0x10108086		; 82546EB (Copper)
  2705 0000106D 86801110            <1> dd 0x10118086		; 82545EM (Fiber)
  2706 00001071 86801210            <1> dd 0x10128086		; 82546EB (Fiber)
  2707 00001075 86801310            <1> dd 0x10138086		; 82541EI
  2708 00001079 86801410            <1> dd 0x10148086		; 82541ER
  2709 0000107D 86801510            <1> dd 0x10158086		; 82540EM (LOM)
  2710 00001081 86801610            <1> dd 0x10168086		; 82540EP (Mobile)
  2711 00001085 86801710            <1> dd 0x10178086		; 82540EP
  2712 00001089 86801810            <1> dd 0x10188086		; 82541EI
  2713 0000108D 86801910            <1> dd 0x10198086		; 82547EI
  2714 00001091 86801A10            <1> dd 0x101a8086		; 82547EI (Mobile)
  2715 00001095 86801D10            <1> dd 0x101d8086		; 82546EB
  2716 00001099 86801E10            <1> dd 0x101e8086		; 82540EP (Mobile)
  2717 0000109D 86802610            <1> dd 0x10268086		; 82545GM
  2718 000010A1 86802710            <1> dd 0x10278086		; 82545GM
  2719 000010A5 86802810            <1> dd 0x10288086		; 82545GM
  2720 000010A9 86805B10            <1> dd 0x105b8086		; 82546GB (Copper)
  2721 000010AD 86807510            <1> dd 0x10758086		; 82547GI
  2722 000010B1 86807610            <1> dd 0x10768086		; 82541GI
  2723 000010B5 86807710            <1> dd 0x10778086		; 82541GI
  2724 000010B9 86807810            <1> dd 0x10788086		; 82541ER
  2725 000010BD 86807910            <1> dd 0x10798086		; 82546GB
  2726 000010C1 86807A10            <1> dd 0x107a8086		; 82546GB
  2727 000010C5 86807B10            <1> dd 0x107b8086		; 82546GB
  2728 000010C9 86807C10            <1> dd 0x107c8086		; 82541PI
  2729 000010CD 8680B510            <1> dd 0x10b58086		; 82546GB (Copper)
  2730 000010D1 86800711            <1> dd 0x11078086		; 82544EI
  2731 000010D5 86801211            <1> dd 0x11128086		; 82544GC
  2732                              <1> 
  2733 000010D9 0000000000000000    <1> dq 0x0000000000000000	; End of list
  2734                              <1> 
  2735                              <1> 
  2736                              <1> ; =============================================================================
  2737                              <1> ; EOF
  2738                                  %include "interrupt.asm"
  2739                              <1> ; =============================================================================
  2740                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  2741                              <1> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  2742                              <1> ;
  2743                              <1> ; Interrupts
  2744                              <1> ; =============================================================================
  2745                              <1> 
  2746                              <1> 
  2747                              <1> ; -----------------------------------------------------------------------------
  2748                              <1> ; Default exception handler
  2749 000010E1 90<rept>            <1> align 8
  2750                              <1> exception_gate:
  2751 000010E8 48BE-               <1> 	mov rsi, int_string00
  2752 000010EA [4514000000000000]  <1>
  2753 000010F2 E8FFF3FFFF          <1> 	call b_output
  2754 000010F7 48BE-               <1> 	mov rsi, exc_string
  2755 000010F9 [7214000000000000]  <1>
  2756 00001101 E8F0F3FFFF          <1> 	call b_output
  2757 00001106 EBFE                <1> 	jmp $				; Hang
  2758                              <1> ; -----------------------------------------------------------------------------
  2759                              <1> 
  2760                              <1> 
  2761                              <1> ; -----------------------------------------------------------------------------
  2762                              <1> ; Default interrupt handler
  2763                              <1> align 8
  2764                              <1> interrupt_gate:				; handler for all other interrupts
  2765 00001108 48CF                <1> 	iretq				; It was an undefined interrupt so return to caller
  2766                              <1> ; -----------------------------------------------------------------------------
  2767                              <1> 
  2768                              <1> 
  2769                              <1> ; -----------------------------------------------------------------------------
  2770                              <1> ; Keyboard interrupt. IRQ 0x01, INT 0x21
  2771                              <1> ; This IRQ runs whenever there is input on the keyboard
  2772 0000110A 90<rept>            <1> align 8
  2773                              <1> keyboard:
  2774 00001110 57                  <1> 	push rdi
  2775 00001111 53                  <1> 	push rbx
  2776 00001112 50                  <1> 	push rax
  2777 00001113 9C                  <1> 	pushfq
  2778 00001114 FC                  <1> 	cld				; Clear direction flag
  2779                              <1> 
  2780 00001115 31C0                <1> 	xor eax, eax
  2781                              <1> 
  2782 00001117 E460                <1> 	in al, 0x60			; Get the scan code from the keyboard
  2783 00001119 3C01                <1> 	cmp al, 0x01
  2784 0000111B 7444                <1> 	je keyboard_escape
  2785 0000111D 3C2A                <1> 	cmp al, 0x2A			; Left Shift Make
  2786 0000111F 7447                <1> 	je keyboard_shift
  2787 00001121 3C36                <1> 	cmp al, 0x36			; Right Shift Make
  2788 00001123 7443                <1> 	je keyboard_shift
  2789 00001125 3CAA                <1> 	cmp al, 0xAA			; Left Shift Break
  2790 00001127 7449                <1> 	je keyboard_noshift
  2791 00001129 3CB6                <1> 	cmp al, 0xB6			; Right Shift Break
  2792 0000112B 7445                <1> 	je keyboard_noshift
  2793 0000112D A880                <1> 	test al, 0x80
  2794 0000112F 7402                <1> 	jz keydown
  2795 00001131 EB33                <1> 	jmp keyup
  2796                              <1> 
  2797                              <1> keydown:
  2798 00001133 803C250403110000    <1> 	cmp byte [key_shift], 0x00
  2799 0000113B 740C                <1> 	je keyboard_lowercase
  2800                              <1> 
  2801                              <1> keyboard_uppercase:
  2802 0000113D 48BB-               <1> 	mov rbx, keylayoutupper
  2803 0000113F [D315000000000000]  <1>
  2804 00001147 EB0A                <1> 	jmp keyboard_processkey
  2805                              <1> 
  2806                              <1> keyboard_lowercase:
  2807 00001149 48BB-               <1> 	mov rbx, keylayoutlower
  2808 0000114B [9815000000000000]  <1>
  2809                              <1> 
  2810                              <1> keyboard_processkey:			; Convert the scan code
  2811 00001153 4801C3              <1> 	add rbx, rax
  2812 00001156 8A1B                <1> 	mov bl, [rbx]
  2813 00001158 881C2503031100      <1> 	mov [key], bl
  2814 0000115F EB1B                <1> 	jmp keyboard_done
  2815                              <1> 
  2816                              <1> keyboard_escape:
  2817 00001161 E93EF6FFFF          <1> 	jmp reboot
  2818                              <1> 
  2819                              <1> keyup:
  2820 00001166 EB14                <1> 	jmp keyboard_done
  2821                              <1> 
  2822                              <1> keyboard_shift:
  2823 00001168 C604250403110001    <1> 	mov byte [key_shift], 0x01
  2824 00001170 EB0A                <1> 	jmp keyboard_done
  2825                              <1> 
  2826                              <1> keyboard_noshift:
  2827 00001172 C604250403110000    <1> 	mov byte [key_shift], 0x00
  2828 0000117A EB00                <1> 	jmp keyboard_done
  2829                              <1> 
  2830                              <1> keyboard_done:
  2831 0000117C B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
  2832 0000117E E620                <1> 	out 0x20, al
  2833 00001180 E87AF7FFFF          <1> 	call b_smp_wakeup_all		; A terrible hack
  2834                              <1> 
  2835 00001185 9D                  <1> 	popfq
  2836 00001186 58                  <1> 	pop rax
  2837 00001187 5B                  <1> 	pop rbx
  2838 00001188 5F                  <1> 	pop rdi
  2839 00001189 48CF                <1> 	iretq
  2840                              <1> ; -----------------------------------------------------------------------------
  2841                              <1> 
  2842                              <1> 
  2843                              <1> ; -----------------------------------------------------------------------------
  2844                              <1> ; Cascade interrupt. IRQ 0x02, INT 0x22
  2845 0000118B 90<rept>            <1> align 8
  2846                              <1> cascade:
  2847 00001190 50                  <1> 	push rax
  2848                              <1> 
  2849 00001191 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
  2850 00001193 E620                <1> 	out 0x20, al
  2851                              <1> 
  2852 00001195 58                  <1> 	pop rax
  2853 00001196 48CF                <1> 	iretq
  2854                              <1> ; -----------------------------------------------------------------------------
  2855                              <1> 
  2856                              <1> 
  2857                              <1> ; -----------------------------------------------------------------------------
  2858                              <1> ; Real-time clock interrupt. IRQ 0x08, INT 0x28
  2859                              <1> ; Currently this IRQ runs 8 times per second (As defined in init_64.asm)
  2860                              <1> ; The supervisor lives here
  2861                              <1> align 8
  2862                              <1> rtc:
  2863 00001198 50                  <1> 	push rax
  2864 00001199 9C                  <1> 	pushfq
  2865 0000119A FC                  <1> 	cld				; Clear direction flag
  2866                              <1> 
  2867 0000119B 488304251000110001  <1> 	add qword [os_ClockCounter], 1	; 64-bit counter started at boot-up
  2868                              <1> 
  2869 000011A4 48833C258000110000  <1> 	cmp qword [os_ClockCallback], 0	; Is it valid?
  2870 000011AD 743B                <1> 	je rtc_end			; If not then bail out.
  2871                              <1> 
  2872                              <1> 	; We could do a 'call [os_ClockCallback]' here but that would not be ideal.
  2873                              <1> 	; A defective callback would hang the system if it never returned back to the
  2874                              <1> 	; interrupt handler. Instead, we modify the stack so that the callback is
  2875                              <1> 	; executed after the interrupt handler has finished. Once the callback has
  2876                              <1> 	; finished, the execution flow will pick up back in the program.
  2877 000011AF 57                  <1> 	push rdi
  2878 000011B0 56                  <1> 	push rsi
  2879 000011B1 51                  <1> 	push rcx
  2880 000011B2 48B9-               <1> 	mov rcx, clock_callback		; RCX stores the callback function address
  2881 000011B4 [B012000000000000]  <1>
  2882 000011BC 4889E6              <1> 	mov rsi, rsp			; Copy the current stack pointer to RSI
  2883 000011BF 4883EC08            <1> 	sub rsp, 8			; Subtract 8 since we add a 64-bit value to the stack
  2884 000011C3 4889E7              <1> 	mov rdi, rsp			; Copy the 'new' stack pointer to RDI
  2885 000011C6 48A5                <1> 	movsq				; RCX
  2886 000011C8 48A5                <1> 	movsq				; RSI
  2887 000011CA 48A5                <1> 	movsq				; RDI
  2888 000011CC 48A5                <1> 	movsq				; Flags
  2889 000011CE 48A5                <1> 	movsq				; RAX
  2890 000011D0 48AD                <1> 	lodsq				; RIP
  2891 000011D2 4891                <1> 	xchg rax, rcx
  2892 000011D4 48AB                <1> 	stosq				; Callback address
  2893 000011D6 48A5                <1> 	movsq				; CS
  2894 000011D8 48A5                <1> 	movsq				; Flags
  2895 000011DA 48AD                <1> 	lodsq				; RSP
  2896 000011DC 4883E808            <1> 	sub rax, 8
  2897 000011E0 48AB                <1> 	stosq
  2898 000011E2 48A5                <1> 	movsq				; SS
  2899 000011E4 488908              <1> 	mov [rax], rcx			; Original RIP
  2900 000011E7 59                  <1> 	pop rcx
  2901 000011E8 5E                  <1> 	pop rsi
  2902 000011E9 5F                  <1> 	pop rdi
  2903                              <1> 
  2904                              <1> rtc_end:
  2905 000011EA B00C                <1> 	mov al, 0x0C			; Select RTC register C
  2906 000011EC E670                <1> 	out 0x70, al			; Port 0x70 is the RTC index, and 0x71 is the RTC data
  2907 000011EE E471                <1> 	in al, 0x71			; Read the value in register C
  2908                              <1> 
  2909 000011F0 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ
  2910 000011F2 E6A0                <1> 	out 0xA0, al
  2911 000011F4 E620                <1> 	out 0x20, al
  2912                              <1> 
  2913 000011F6 9D                  <1> 	popfq
  2914 000011F7 58                  <1> 	pop rax
  2915 000011F8 48CF                <1> 	iretq
  2916                              <1> ; -----------------------------------------------------------------------------
  2917                              <1> 
  2918                              <1> 
  2919                              <1> ; -----------------------------------------------------------------------------
  2920                              <1> ; Network interrupt handler
  2921 000011FA 90<rept>            <1> align 8
  2922                              <1> network:
  2923 00001200 57                  <1> 	push rdi
  2924 00001201 56                  <1> 	push rsi
  2925 00001202 51                  <1> 	push rcx
  2926 00001203 50                  <1> 	push rax
  2927 00001204 9C                  <1> 	pushfq
  2928 00001205 FC                  <1> 	cld				; Clear direction flag
  2929                              <1> 
  2930 00001206 E849F6FFFF          <1> 	call b_net_ack_int		; Call the driver function to acknowledge the interrupt internally
  2931                              <1> 
  2932 0000120B 660FBAE000          <1> 	bt ax, 0			; TX bit set (caused the IRQ?)
  2933 00001210 7266                <1> 	jc network_tx			; If so then jump past RX section
  2934 00001212 660FBAE007          <1> 	bt ax, 7			; RX bit set
  2935 00001217 736E                <1> 	jnc network_end
  2936                              <1> network_rx_as_well:
  2937 00001219 C604250C03110001    <1> 	mov byte [os_NetActivity_RX], 1
  2938 00001221 BF00001400          <1> 	mov rdi, os_EthernetBuffer	; Raw packet is copied here
  2939 00001226 57                  <1> 	push rdi
  2940 00001227 4883C702            <1> 	add rdi, 2
  2941 0000122B E82CF6FFFF          <1> 	call b_net_rx_from_interrupt
  2942 00001230 5F                  <1> 	pop rdi
  2943 00001231 4889C8              <1> 	mov rax, rcx
  2944 00001234 66AB                <1> 	stosw				; Store the size of the packet
  2945 00001236 48833C256800110000  <1> 	cmp qword [os_NetworkCallback], 0	; Is it valid?
  2946 0000123F 7446                <1> 	je network_end			; If not then bail out.
  2947                              <1> 
  2948                              <1> 	; We could do a 'call [os_NetworkCallback]' here but that would not be ideal.
  2949                              <1> 	; A defective callback would hang the system if it never returned back to the
  2950                              <1> 	; interrupt handler. Instead, we modify the stack so that the callback is
  2951                              <1> 	; executed after the interrupt handler has finished. Once the callback has
  2952                              <1> 	; finished, the execution flow will pick up back in the program.
  2953 00001241 48B9-               <1> 	mov rcx, network_callback	; RCX stores the callback function address
  2954 00001243 [A012000000000000]  <1>
  2955 0000124B 4889E6              <1> 	mov rsi, rsp			; Copy the current stack pointer to RSI
  2956 0000124E 4883EC08            <1> 	sub rsp, 8			; Subtract 8 since we add a 64-bit value to the stack
  2957 00001252 4889E7              <1> 	mov rdi, rsp			; Copy the 'new' stack pointer to RDI
  2958 00001255 48A5                <1> 	movsq				; Flags
  2959 00001257 48A5                <1> 	movsq				; RAX
  2960 00001259 48A5                <1> 	movsq				; RCX
  2961 0000125B 48A5                <1> 	movsq				; RSI
  2962 0000125D 48A5                <1> 	movsq				; RDI
  2963 0000125F 48AD                <1> 	lodsq				; RIP
  2964 00001261 4891                <1> 	xchg rax, rcx
  2965 00001263 48AB                <1> 	stosq				; Callback address
  2966 00001265 48A5                <1> 	movsq				; CS
  2967 00001267 48A5                <1> 	movsq				; Flags
  2968 00001269 48AD                <1> 	lodsq				; RSP
  2969 0000126B 4883E808            <1> 	sub rax, 8
  2970 0000126F 48AB                <1> 	stosq
  2971 00001271 48A5                <1> 	movsq				; SS
  2972 00001273 488908              <1> 	mov [rax], rcx			; Original RIP
  2973 00001276 EB0F                <1> 	jmp network_end
  2974                              <1> 
  2975                              <1> network_tx:
  2976 00001278 C604250B03110001    <1> 	mov byte [os_NetActivity_TX], 1
  2977 00001280 660FBAE007          <1> 	bt ax, 7
  2978 00001285 7292                <1> 	jc network_rx_as_well
  2979                              <1> 
  2980                              <1> network_end:
  2981 00001287 B020                <1> 	mov al, 0x20			; Acknowledge the IRQ on the PIC(s)
  2982 00001289 803C250A03110008    <1> 	cmp byte [os_NetIRQ], 8
  2983 00001291 7C02                <1> 	jl network_ack_only_low		; If the network IRQ is less than 8 then the other PIC does not need to be ack'ed
  2984 00001293 E6A0                <1> 	out 0xA0, al
  2985                              <1> network_ack_only_low:
  2986 00001295 E620                <1> 	out 0x20, al
  2987                              <1> 
  2988 00001297 9D                  <1> 	popfq
  2989 00001298 58                  <1> 	pop rax
  2990 00001299 59                  <1> 	pop rcx
  2991 0000129A 5E                  <1> 	pop rsi
  2992 0000129B 5F                  <1> 	pop rdi
  2993 0000129C 48CF                <1> 	iretq
  2994                              <1> ; -----------------------------------------------------------------------------
  2995                              <1> 
  2996                              <1> 
  2997                              <1> ; -----------------------------------------------------------------------------
  2998                              <1> ; Network interrupt callback.
  2999 0000129E 90<rept>            <1> align 8
  3000                              <1> network_callback:
  3001 000012A0 9C                  <1> 	pushfq
  3002 000012A1 FC                  <1> 	cld				; Clear direction flag
  3003 000012A2 FF142568001100      <1> 	call [os_NetworkCallback]
  3004 000012A9 9D                  <1> 	popfq
  3005 000012AA C3                  <1> 	ret
  3006                              <1> ; -----------------------------------------------------------------------------
  3007                              <1> 
  3008                              <1> 
  3009                              <1> ; -----------------------------------------------------------------------------
  3010                              <1> ; Clock interrupt callback.
  3011 000012AB 90<rept>            <1> align 8
  3012                              <1> clock_callback:
  3013 000012B0 9C                  <1> 	pushfq
  3014 000012B1 FC                  <1> 	cld				; Clear direction flag
  3015 000012B2 FF142580001100      <1> 	call [os_ClockCallback]
  3016 000012B9 9D                  <1> 	popfq
  3017 000012BA C3                  <1> 	ret
  3018                              <1> ; -----------------------------------------------------------------------------
  3019                              <1> 
  3020                              <1> 
  3021                              <1> ; -----------------------------------------------------------------------------
  3022                              <1> ; A simple interrupt that just acknowledges an IPI. Useful for getting an AP past a 'hlt' in the code.
  3023 000012BB 90<rept>            <1> align 8
  3024                              <1> ap_wakeup:
  3025 000012C0 57                  <1> 	push rdi
  3026 000012C1 50                  <1> 	push rax
  3027                              <1> 
  3028 000012C2 488B3C2500001100    <1> 	mov rdi, [os_LocalAPICAddress]	; Acknowledge the IPI
  3029 000012CA 4881C7B0000000      <1> 	add rdi, 0xB0
  3030 000012D1 31C0                <1> 	xor eax, eax
  3031 000012D3 AB                  <1> 	stosd
  3032                              <1> 
  3033 000012D4 58                  <1> 	pop rax
  3034 000012D5 5F                  <1> 	pop rdi
  3035 000012D6 48CF                <1> 	iretq				; Return from the IPI.
  3036                              <1> ; -----------------------------------------------------------------------------
  3037                              <1> 
  3038                              <1> 
  3039                              <1> ; -----------------------------------------------------------------------------
  3040                              <1> ; Resets a CPU to execute ap_clear
  3041                              <1> align 8
  3042                              <1> ap_reset:
  3043 000012D8 48B8-               <1> 	mov rax, ap_clear		; Set RAX to the address of ap_clear
  3044 000012DA [C000000000000000]  <1>
  3045 000012E2 48890424            <1> 	mov [rsp], rax			; Overwrite the return address on the CPU's stack
  3046 000012E6 488B3C2500001100    <1> 	mov rdi, [os_LocalAPICAddress]	; Acknowledge the IPI
  3047 000012EE 4881C7B0000000      <1> 	add rdi, 0xB0
  3048 000012F5 31C0                <1> 	xor eax, eax
  3049 000012F7 AB                  <1> 	stosd
  3050 000012F8 48CF                <1> 	iretq				; Return from the IPI. CPU will execute code at ap_clear
  3051                              <1> ; -----------------------------------------------------------------------------
  3052                              <1> 
  3053                              <1> 
  3054                              <1> ; -----------------------------------------------------------------------------
  3055                              <1> ; CPU Exception Gates
  3056 000012FA 90<rept>            <1> align 8
  3057                              <1> exception_gate_00:
  3058 00001300 50                  <1> 	push rax
  3059 00001301 B000                <1> 	mov al, 0x00
  3060 00001303 E998000000          <1> 	jmp exception_gate_main
  3061                              <1> 
  3062                              <1> align 8
  3063                              <1> exception_gate_01:
  3064 00001308 50                  <1> 	push rax
  3065 00001309 B001                <1> 	mov al, 0x01
  3066 0000130B E990000000          <1> 	jmp exception_gate_main
  3067                              <1> 
  3068                              <1> align 8
  3069                              <1> exception_gate_02:
  3070 00001310 50                  <1> 	push rax
  3071 00001311 B002                <1> 	mov al, 0x02
  3072 00001313 E988000000          <1> 	jmp exception_gate_main
  3073                              <1> 
  3074                              <1> align 8
  3075                              <1> exception_gate_03:
  3076 00001318 50                  <1> 	push rax
  3077 00001319 B003                <1> 	mov al, 0x03
  3078 0000131B E980000000          <1> 	jmp exception_gate_main
  3079                              <1> 
  3080                              <1> align 8
  3081                              <1> exception_gate_04:
  3082 00001320 50                  <1> 	push rax
  3083 00001321 B004                <1> 	mov al, 0x04
  3084 00001323 EB7B                <1> 	jmp exception_gate_main
  3085                              <1> 
  3086 00001325 90<rept>            <1> align 8
  3087                              <1> exception_gate_05:
  3088 00001328 50                  <1> 	push rax
  3089 00001329 B005                <1> 	mov al, 0x05
  3090 0000132B EB73                <1> 	jmp exception_gate_main
  3091                              <1> 
  3092 0000132D 90<rept>            <1> align 8
  3093                              <1> exception_gate_06:
  3094 00001330 50                  <1> 	push rax
  3095 00001331 B006                <1> 	mov al, 0x06
  3096 00001333 EB6B                <1> 	jmp exception_gate_main
  3097                              <1> 
  3098 00001335 90<rept>            <1> align 8
  3099                              <1> exception_gate_07:
  3100 00001338 50                  <1> 	push rax
  3101 00001339 B007                <1> 	mov al, 0x07
  3102 0000133B EB63                <1> 	jmp exception_gate_main
  3103                              <1> 
  3104 0000133D 90<rept>            <1> align 8
  3105                              <1> exception_gate_08:
  3106 00001340 50                  <1> 	push rax
  3107 00001341 B008                <1> 	mov al, 0x08
  3108 00001343 EB5B                <1> 	jmp exception_gate_main
  3109                              <1> 
  3110 00001345 90<rept>            <1> align 8
  3111                              <1> exception_gate_09:
  3112 00001348 50                  <1> 	push rax
  3113 00001349 B009                <1> 	mov al, 0x09
  3114 0000134B EB53                <1> 	jmp exception_gate_main
  3115                              <1> 
  3116 0000134D 90<rept>            <1> align 8
  3117                              <1> exception_gate_10:
  3118 00001350 50                  <1> 	push rax
  3119 00001351 B00A                <1> 	mov al, 0x0A
  3120 00001353 EB4B                <1> 	jmp exception_gate_main
  3121                              <1> 
  3122 00001355 90<rept>            <1> align 8
  3123                              <1> exception_gate_11:
  3124 00001358 50                  <1> 	push rax
  3125 00001359 B00B                <1> 	mov al, 0x0B
  3126 0000135B EB43                <1> 	jmp exception_gate_main
  3127                              <1> 
  3128 0000135D 90<rept>            <1> align 8
  3129                              <1> exception_gate_12:
  3130 00001360 50                  <1> 	push rax
  3131 00001361 B00C                <1> 	mov al, 0x0C
  3132 00001363 EB3B                <1> 	jmp exception_gate_main
  3133                              <1> 
  3134 00001365 90<rept>            <1> align 8
  3135                              <1> exception_gate_13:
  3136 00001368 50                  <1> 	push rax
  3137 00001369 B00D                <1> 	mov al, 0x0D
  3138 0000136B EB33                <1> 	jmp exception_gate_main
  3139                              <1> 
  3140 0000136D 90<rept>            <1> align 8
  3141                              <1> exception_gate_14:
  3142 00001370 50                  <1> 	push rax
  3143 00001371 B00E                <1> 	mov al, 0x0E
  3144 00001373 EB2B                <1> 	jmp exception_gate_main
  3145                              <1> 
  3146 00001375 90<rept>            <1> align 8
  3147                              <1> exception_gate_15:
  3148 00001378 50                  <1> 	push rax
  3149 00001379 B00F                <1> 	mov al, 0x0F
  3150 0000137B EB23                <1> 	jmp exception_gate_main
  3151                              <1> 
  3152 0000137D 90<rept>            <1> align 8
  3153                              <1> exception_gate_16:
  3154 00001380 50                  <1> 	push rax
  3155 00001381 B010                <1> 	mov al, 0x10
  3156 00001383 EB1B                <1> 	jmp exception_gate_main
  3157                              <1> 
  3158 00001385 90<rept>            <1> align 8
  3159                              <1> exception_gate_17:
  3160 00001388 50                  <1> 	push rax
  3161 00001389 B011                <1> 	mov al, 0x11
  3162 0000138B EB13                <1> 	jmp exception_gate_main
  3163                              <1> 
  3164 0000138D 90<rept>            <1> align 8
  3165                              <1> exception_gate_18:
  3166 00001390 50                  <1> 	push rax
  3167 00001391 B012                <1> 	mov al, 0x12
  3168 00001393 EB0B                <1> 	jmp exception_gate_main
  3169                              <1> 
  3170 00001395 90<rept>            <1> align 8
  3171                              <1> exception_gate_19:
  3172 00001398 50                  <1> 	push rax
  3173 00001399 B013                <1> 	mov al, 0x13
  3174 0000139B EB03                <1> 	jmp exception_gate_main
  3175                              <1> 
  3176 0000139D 90<rept>            <1> align 8
  3177                              <1> exception_gate_main:
  3178 000013A0 48C704256800110000- <1> 	mov qword [os_NetworkCallback], 0	; Reset the network callback
  3179 000013A9 000000              <1>
  3180 000013AC 48C704258000110000- <1> 	mov qword [os_ClockCallback], 0		; Reset the clockk callback
  3181 000013B5 000000              <1>
  3182 000013B8 53                  <1> 	push rbx
  3183 000013B9 57                  <1> 	push rdi
  3184 000013BA 56                  <1> 	push rsi
  3185 000013BB 51                  <1> 	push rcx			; Char counter for b_output
  3186 000013BC 50                  <1> 	push rax			; Save RAX since b_smp_get_id clobbers it
  3187 000013BD 48BE-               <1> 	mov rsi, newline
  3188 000013BF [5E15000000000000]  <1>
  3189 000013C7 B901000000          <1> 	mov rcx, 1
  3190 000013CC E825F1FFFF          <1> 	call b_output
  3191 000013D1 48BE-               <1> 	mov rsi, int_string00
  3192 000013D3 [4514000000000000]  <1>
  3193 000013DB B918000000          <1> 	mov rcx, 24
  3194 000013E0 E811F1FFFF          <1> 	call b_output
  3195 000013E5 E835F5FFFF          <1> 	call b_smp_get_id		; Get the local CPU ID and print it
  3196 000013EA E86AF3FFFF          <1> 	call os_debug_dump_ax
  3197 000013EF 48BE-               <1> 	mov rsi, int_string01
  3198 000013F1 [5E14000000000000]  <1>
  3199 000013F9 B90D000000          <1> 	mov rcx, 13
  3200 000013FE E8F3F0FFFF          <1> 	call b_output
  3201 00001403 48BE-               <1> 	mov rsi, exc_string00
  3202 00001405 [8B14000000000000]  <1>
  3203 0000140D 58                  <1> 	pop rax
  3204 0000140E 4825FF000000        <1> 	and rax, 0x00000000000000FF	; Clear out everything in RAX except for AL
  3205 00001414 50                  <1> 	push rax
  3206 00001415 B308                <1> 	mov bl, 8			; Length of each message
  3207 00001417 F6E3                <1> 	mul bl				; AX = AL x BL
  3208 00001419 4801C6              <1> 	add rsi, rax			; Use the value in RAX as an offset to get to the right message
  3209 0000141C 58                  <1> 	pop rax
  3210 0000141D B30F                <1> 	mov bl, 0x0F
  3211 0000141F B907000000          <1> 	mov rcx, 7
  3212 00001424 E8CDF0FFFF          <1> 	call b_output
  3213 00001429 5E                  <1> 	pop rsi
  3214 0000142A 5F                  <1> 	pop rdi
  3215 0000142B 5B                  <1> 	pop rbx
  3216 0000142C 58                  <1> 	pop rax
  3217                              <1> ;	mov rsi, int_string02
  3218                              <1> ;	call b_output
  3219 0000142D 50                  <1> 	push rax
  3220 0000142E 488B442408          <1> 	mov rax, [rsp+0x08] 		; RIP of caller
  3221 00001433 E8E6F2FFFF          <1> 	call os_debug_dump_rax
  3222 00001438 58                  <1> 	pop rax
  3223                              <1> ;	call os_print_newline
  3224 00001439 EBFE                <1> 	jmp $				; For debugging
  3225 0000143B E8A9EEFFFF          <1> 	call init_memory_map
  3226 00001440 E97BECFFFF          <1> 	jmp ap_clear			; jump to AP clear code
  3227                              <1> 
  3228                              <1> 
  3229 00001445 466174616C20457863- <1> int_string00 db 'Fatal Exception - CPU 0x', 0
  3230 0000144E 657074696F6E202D20- <1>
  3231 00001457 43505520307800      <1>
  3232 0000145E 202D20496E74657272- <1> int_string01 db ' - Interrupt ', 0
  3233 00001467 7570742000          <1>
  3234 0000146C 204020307800        <1> int_string02 db ' @ 0x', 0
  3235                              <1> ; Strings for the error messages
  3236 00001472 556E6B6E6F776E2046- <1> exc_string db 'Unknown Fatal Exception!', 0
  3237 0000147B 6174616C2045786365- <1>
  3238 00001484 7074696F6E2100      <1>
  3239 0000148B 3030202844452900    <1> exc_string00 db '00 (DE)', 0
  3240 00001493 3031202844422900    <1> exc_string01 db '01 (DB)', 0
  3241 0000149B 3032202020202000    <1> exc_string02 db '02     ', 0
  3242 000014A3 3033202842502900    <1> exc_string03 db '03 (BP)', 0
  3243 000014AB 303420284F462900    <1> exc_string04 db '04 (OF)', 0
  3244 000014B3 3035202842522900    <1> exc_string05 db '05 (BR)', 0
  3245 000014BB 3036202855442900    <1> exc_string06 db '06 (UD)', 0
  3246 000014C3 303720284E4D2900    <1> exc_string07 db '07 (NM)', 0
  3247 000014CB 3038202844462900    <1> exc_string08 db '08 (DF)', 0
  3248 000014D3 3039202020202000    <1> exc_string09 db '09     ', 0	; No longer generated on new CPU's
  3249 000014DB 3130202854532900    <1> exc_string10 db '10 (TS)', 0
  3250 000014E3 313120284E502900    <1> exc_string11 db '11 (NP)', 0
  3251 000014EB 3132202853532900    <1> exc_string12 db '12 (SS)', 0
  3252 000014F3 3133202847502900    <1> exc_string13 db '13 (GP)', 0
  3253 000014FB 3134202850462900    <1> exc_string14 db '14 (PF)', 0
  3254 00001503 3135202020202000    <1> exc_string15 db '15     ', 0
  3255 0000150B 313620284D462900    <1> exc_string16 db '16 (MF)', 0
  3256 00001513 3137202841432900    <1> exc_string17 db '17 (AC)', 0
  3257 0000151B 313820284D432900    <1> exc_string18 db '18 (MC)', 0
  3258 00001523 31392028584D2900    <1> exc_string19 db '19 (XM)', 0
  3259                              <1> 
  3260                              <1> 
  3261                              <1> ; =============================================================================
  3262                              <1> ; EOF
  3263                                  %include "sysvar.asm"			; Include this last to keep the read/write variables away from the code
  3264                              <1> ; =============================================================================
  3265                              <1> ; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems
  3266                              <1> ; Copyright (C) 2008-2017 Return Infinity -- see LICENSE.TXT
  3267                              <1> ;
  3268                              <1> ; System Variables
  3269                              <1> ; =============================================================================
  3270                              <1> 
  3271                              <1> 
  3272                              <1> ; Constants
  3273 0000152B 303132333435363738- <1> hextable: 		db '0123456789ABCDEF'
  3274 00001534 39414243444546      <1>
  3275                              <1> 
  3276                              <1> ; Strings
  3277 0000153B 426172654D6574616C- <1> system_status_header:	db 'BareMetal v1.0.0', 0
  3278 00001544 2076312E302E3000    <1>
  3279 0000154C 426172654D6574616C- <1> readymsg:		db 'BareMetal is ready'	; This string falls thru to newline
  3280 00001555 206973207265616479  <1>
  3281 0000155E 0A00                <1> newline:		db 10, 0
  3282 00001560 4E6F7420656E6F7567- <1> memory_message:		db 'Not enough system memory for CPU stacks! System halted.', 0
  3283 00001569 682073797374656D20- <1>
  3284 00001572 6D656D6F727920666F- <1>
  3285 0000157B 722043505520737461- <1>
  3286 00001584 636B73212053797374- <1>
  3287 0000158D 656D2068616C746564- <1>
  3288 00001596 2E00                <1>
  3289                              <1> 
  3290                              <1> ; Memory addresses
  3291                              <1> sys_idt:		equ 0x0000000000000000	; 4096 bytes	0x000000 -> 0x000FFF	Interrupt descriptor table
  3292                              <1> sys_gdt:		equ 0x0000000000001000	; 4096 bytes	0x001000 -> 0x001FFF	Global descriptor table
  3293                              <1> sys_pml4:		equ 0x0000000000002000	; 4096 bytes	0x002000 -> 0x002FFF	PML4 table
  3294                              <1> sys_pdpl:		equ 0x0000000000003000	; 4096 bytes	0x003000 -> 0x003FFF	PDP table low
  3295                              <1> sys_pdph:		equ 0x0000000000004000	; 4096 bytes	0x004000 -> 0x004FFF	PDP table high
  3296                              <1> sys_Pure64:		equ 0x0000000000005000	; 12288 bytes	0x005000 -> 0x007FFF	Pure64 system data
  3297                              <1> sys_pdl:		equ 0x0000000000010000	; 65536 bytes	0x010000 -> 0x01FFFF	Page directory low
  3298                              <1> sys_pdh:		equ 0x0000000000020000	; 262144 bytes	0x020000 -> 0x05FFFF	Page directory high
  3299                              <1> ahci_cmdlist:		equ 0x0000000000070000	; 4096 bytes	0x070000 -> 0x071FFF
  3300                              <1> ahci_receivedfis:	equ 0x0000000000071000	; 4096 bytes	0x071000 -> 0x072FFF
  3301                              <1> ahci_cmdtable:		equ 0x0000000000072000	; 57344 bytes	0x072000 -> 0x07FFFF
  3302                              <1> os_temp_string:		equ 0x0000000000080400	; 1024 bytes	0x080400 -> 0x0807FF
  3303                              <1> os_args:		equ 0x0000000000080C00
  3304                              <1> sys_ROM:		equ 0x00000000000A0000	; 393216 bytes	0x0A0000 -> 0x0FFFFF
  3305                              <1> os_KernelStart:		equ 0x0000000000100000	; 65536 bytes	0x100000 -> 0x10FFFF	Location of Kernel
  3306                              <1> os_SystemVariables:	equ 0x0000000000110000	; 65536 bytes	0x110000 -> 0x11FFFF	Location of System Variables
  3307                              <1> os_MemoryMap:		equ 0x0000000000120000	; 131072 bytes	0x120000 -> 0x13FFFF	Location of Memory Map - Room to map 256 GiB with 2 MiB pages
  3308                              <1> os_EthernetBuffer:	equ 0x0000000000140000	; 262144 bytes	0x140000 -> 0x17FFFF	Location of Ethernet RX Ring Buffer - Room for 170 packets
  3309                              <1> os_temp:		equ 0x0000000000190000
  3310                              <1> os_rx_desc:		equ 0x00000000001A0000	; 32768 bytes	0x1A0000 -> 0x1A7FFF	Ethernet receive descriptors
  3311                              <1> os_tx_desc:		equ 0x00000000001A8000	; 32768 bytes	0x1A8000 -> 0x1AFFFF	Ethernet transmit descriptors
  3312                              <1> os_cpu_work_table:	equ 0x00000000001FF000	; Location of CPU Queue. Each queue item is 16 bytes. (4KiB before the 2MiB mark, Room for 256 entries)
  3313                              <1> programlocation:	equ 0x0000000000200000	; Location in memory where programs are loaded (the start of 2MiB)
  3314                              <1> 
  3315                              <1> ; DQ - Starting at offset 0, increments by 8
  3316                              <1> os_LocalAPICAddress:	equ os_SystemVariables + 0
  3317                              <1> os_IOAPICAddress:	equ os_SystemVariables + 8
  3318                              <1> os_ClockCounter:	equ os_SystemVariables + 16
  3319                              <1> os_StackBase:		equ os_SystemVariables + 40
  3320                              <1> os_net_transmit:	equ os_SystemVariables + 48
  3321                              <1> os_net_poll:		equ os_SystemVariables + 56
  3322                              <1> os_net_ackint:		equ os_SystemVariables + 64
  3323                              <1> os_NetIOBaseMem:	equ os_SystemVariables + 72
  3324                              <1> os_NetMAC:		equ os_SystemVariables + 80
  3325                              <1> os_HPETAddress:		equ os_SystemVariables + 88
  3326                              <1> ahci_base:		equ os_SystemVariables + 96
  3327                              <1> os_NetworkCallback:	equ os_SystemVariables + 104
  3328                              <1> os_KeyboardCallback:	equ os_SystemVariables + 120
  3329                              <1> os_ClockCallback:	equ os_SystemVariables + 128
  3330                              <1> os_net_TXBytes:		equ os_SystemVariables + 136
  3331                              <1> os_net_TXPackets:	equ os_SystemVariables + 144
  3332                              <1> os_net_RXBytes:		equ os_SystemVariables + 152
  3333                              <1> os_net_RXPackets:	equ os_SystemVariables + 160
  3334                              <1> os_hdd_BytesRead:	equ os_SystemVariables + 168
  3335                              <1> os_hdd_BytesWrite:	equ os_SystemVariables + 176
  3336                              <1> 
  3337                              <1> ; DD - Starting at offset 256, increments by 4
  3338                              <1> cpu_speed:		equ os_SystemVariables + 256	; in MHz
  3339                              <1> os_HPETRate:		equ os_SystemVariables + 260
  3340                              <1> os_MemAmount:		equ os_SystemVariables + 264	; in MiB
  3341                              <1> ahci_port:		equ os_SystemVariables + 268
  3342                              <1> hd1_size:		equ os_SystemVariables + 272	; in MiB
  3343                              <1> 
  3344                              <1> ; DW - Starting at offset 512, increments by 2
  3345                              <1> os_NumCores:		equ os_SystemVariables + 512
  3346                              <1> os_NetIOAddress:	equ os_SystemVariables + 522
  3347                              <1> os_NetLock:		equ os_SystemVariables + 524
  3348                              <1> 
  3349                              <1> ; DB - Starting at offset 768, increments by 1
  3350                              <1> scancode:		equ os_SystemVariables + 770
  3351                              <1> key:			equ os_SystemVariables + 771
  3352                              <1> key_shift:		equ os_SystemVariables + 772
  3353                              <1> os_PCIEnabled:		equ os_SystemVariables + 775	; 1 if PCI is detected
  3354                              <1> os_NetEnabled:		equ os_SystemVariables + 776	; 1 if a supported network card was enabled
  3355                              <1> os_NetIRQ:		equ os_SystemVariables + 778	; Set to Interrupt line that NIC is connected to
  3356                              <1> os_NetActivity_TX:	equ os_SystemVariables + 779
  3357                              <1> os_NetActivity_RX:	equ os_SystemVariables + 780
  3358                              <1> os_EthernetBuffer_C1:	equ os_SystemVariables + 781	; Counter 1 for the Ethernet RX Ring Buffer
  3359                              <1> os_EthernetBuffer_C2:	equ os_SystemVariables + 782	; Counter 2 for the Ethernet RX Ring Buffer
  3360                              <1> os_DiskEnabled:		equ os_SystemVariables + 783
  3361                              <1> os_DiskActivity:	equ os_SystemVariables + 784
  3362                              <1> app_argc:		equ os_SystemVariables + 785
  3363                              <1> 
  3364                              <1> 
  3365                              <1> keylayoutlower:
  3366 00001598 000031323334353637- <1> db 0x00, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0x0e, 0, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0x1c, 0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', 0x27, '`', 0, '
  3367 000015A1 3839302D3D0E007177- <1>
  3368 000015AA 6572747975696F705B- <1>
  3369 000015B3 5D1C00617364666768- <1>
  3370 000015BC 6A6B6C3B2760005C7A- <1>
  3371 000015C5 786376626E6D2C2E2F- <1>
  3372 000015CE 0000002000          <1>
  3373                              <1> keylayoutupper:
  3374 000015D3 000021402324255E26- <1> db 0x00, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0x0e, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0x1c, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', 0x22, '~', 0, '
  3375 000015DC 2A28295F2B0E005157- <1>
  3376 000015E5 4552545955494F507B- <1>
  3377 000015EE 7D1C00415344464748- <1>
  3378 000015F7 4A4B4C3A227E007C5A- <1>
  3379 00001600 584356424E4D3C3E3F- <1>
  3380 00001609 0000002000          <1>
  3381                              <1> ; 0e = backspace
  3382                              <1> ; 1c = enter
  3383 0000160E 0000                <1> tchar: db 0, 0
  3384                              <1> 
  3385                              <1> 
  3386                              <1> ;------------------------------------------------------------------------------
  3387                              <1> 
  3388                              <1> SYS64_CODE_SEL	equ 8		; defined by Pure64
  3389                              <1> 
  3390                              <1> ; =============================================================================
  3391                              <1> ; EOF
  3392                                  
  3393 00001610 00<rept>                times KERNELSIZE-($-$$) db 0		; Set the compiled kernel binary to at least this size in bytes
  3394                                  
  3395                                  
  3396                                  ; =============================================================================
  3397                                  ; EOF
